{"./":{"url":"./","title":"この資料について","keywords":"","body":"この資料について これは、サービス開発リファレンスのひとつとして提供している「ハンズオンコンテンツ」の資料です。 ハンズオンコンテンツは、常に活用して頂ける状態にするため、利用者からのフィードバックや技術トレンド等に合わせて、継続的にアップデートを行います。 サービス開発リファレンス全体の紹介についてはこちらをご参照ください。 ご利用にあたって 当サイトでは、ブラウザによる閲覧履歴等の情報を収集しております。 以下に、情報の利用目的や各情報の具体的な用途を示します。 情報の利用目的 取得した情報はアクセス解析に利用されます。 ページのアクセス数等からサイトの利用状況を把握し、サイトの改善に利用します。 アクセス情報は匿名で収集され、個人を特定することはできません。 情報の送信先 取得した情報はPlausible Analyticsに送信されます。 情報の種類・用途 利用する情報は以下のとおりです。 情報の種類 例 説明 用途 ページのURL https://fintan-contents.github.io/spa-restapi-handson/ 当ウェブサイトのURL どのページが閲覧されたか測定するために使用されます。 リファラー https://twitter.com/ 参照元ページ どのページから当サイトに到達したかを測定するために使用されます。 ブラウザ Chrome 86.0 利用者のブラウザの種類 利用者の閲覧環境を測定するために使用されます1。 OS macOS 10.15 利用者のOSの種類 利用者の閲覧環境を測定するために使用されます1。 デバイス種別 Desktop 利用者のデバイスの種類 利用者の閲覧環境を測定するために使用されます1。 国、地域、都市 United Kingdom, England, London 利用者の位置情報 利用者の閲覧環境を測定するために使用されます2。 1. ユーザーエージェントから取得しますが、必要な情報だけを使用します。完全なユーザーエージェントは破棄されます。 ↩ 2. IPアドレスを使用して位置情報を取得しますが、都市レベルより詳細な追跡は行いません。IPアドレスは破棄されるため、データベース等に保存されることはありません。 ↩ より詳細な情報については、Plausible Analyticsのポリシーをご参照ください。 "},"intro/":{"url":"intro/","title":"はじめに","keywords":"","body":"はじめに ハンズオンの目的 本ハンズオンは、JavaでWebアプリケーションの開発経験はあるが、シングルページアプリケーション(以下SPA）とREST APIを組み合わせた構成での開発経験が無い開発者を対象とし、次のことについて学ぶことを目的としています。 ReactとTypeScriptを使用したSPAの実装 Nablarchを使用したREST APIの実装 （ReactやTypeScirpt、Nablarchについては使用経験が無くても問題ありません） なお、いくつかの機能を実現するための実装は、サービス開発リファレンスのサンプルアプリケーション（以下example-chat）でも同様に実装されています。そのため、example-chatの実装を参考にできたり流用できたりする箇所では積極的に使用するようにしています。 ハンズオンの内容 本ハンズオンでは、ToDoを管理するためのサービスを提供するToDoアプリを作成します。 ToDoアプリは、フロントエンドをSPA、バックエンドをREST APIで構成します。SPAの実装にはReactとTypeScriptを、REST APIの実装にはNablarchを使用します。また、フロントエンドとバックエンドを分離して実装しやすいようにOpenAPIを使用します。 本ハンズオンはSPAとREST APIの実装を体験することに焦点を当てた内容としています。そのため、実際の開発プロセスとは異なり、画面デザインやアプリアーキテクチャ、バックエンドの一部実装については決まっているものとし、それを元に実装を進めていきます。 SPAについては開発経験が無いことを前提としているため、理解しやすくするためにReactがガイドしている開発ステップに近しくなるように進めていきます。そのため、コンポーネント分割等の一部の設計については進めながら行う内容としています。（Reactのガイドについては事前に読んでおく必要はありません。関連箇所では都度リンクを記載しますので、詳細を確認したい場合はリンク先を確認するようにしてください） アプリの仕様やアーキテクチャの詳細については、後述します。 "},"setup/":{"url":"setup/","title":"ハンズオンの準備","keywords":"","body":"ハンズオンの準備 ToDoアプリを開発するための準備を行います。 目次 開発環境の準備 開発環境を準備するため、各種ツールをインストールします。 資料のダウンロード ハンズオンで使用する資料を、開発端末にダウンロードします。 "},"setup/download/":{"url":"setup/download/","title":"資料のダウンロード","keywords":"","body":"資料のダウンロード ハンズオン資料のダウンロード ハンズオンで使用する資料が、GitHubのspa-restapi-handsonリポジトリに格納されています。 本ドキュメント プロジェクトのひな形 ToDoアプリのデザインモック ToDoアプリの実装サンプル Gitをインストールしている場合は、以下のコマンドでリポジトリをクローンしてください。 $ git clone https://github.com/Fintan-contents/spa-restapi-handson.git Gitをインストールしていない、もしくは使わない場合は、以下のリンクからzipファイルをダウンロードし、任意の場所に解凍してください。 GitHubからzipファイルをダウンロード サービス開発リファレンスのサンプルアプリケーションをダウンロード ハンズオンで使用するサービス開発リファレンスのサンプルアプリケーション（以下example-caht）が、GitHubのexample-chatリポジトリに格納されています。 Gitをインストールしている場合は、以下のコマンドでリポジトリをクローンしてください。 $ git clone https://github.com/Fintan-contents/example-chat.git Gitをインストールしていない、もしくは使わない場合は、以下のリンクからzipファイルをダウンロードし、任意の場所に解凍してください。 GitHubからzipファイルをダウンロード "},"todo-spec/":{"url":"todo-spec/","title":"ToDoアプリの仕様説明","keywords":"","body":"ToDoアプリの仕様説明 事前に決めているToDoアプリの仕様は、次のとおりです。 機能 ToDoアプリは、ToDoを管理するためのサービスを提供するため、次の機能を実現します。 ToDoを登録できる 登録しているToDoを一覧形式で表示できる ToDoを完了にできる ToDoの完了を取り消せる ToDoを削除できる 表示するToDoを絞り込むことができる サービスは複数のユーザーが利用できる想定とし、ユーザーは自身が登録したToDoを操作できます。サービスを利用するためには、アカウントを登録してユーザー認証を行う必要があります。 画面構成・デザイン 画面構成およびデザインは、次のとおりです。デザインモックはspa-restapi-handson/design-mockに配置しています。 トップページ サインアップページ ログインページ ToDoページ アプリ構成 フロントエンドをSPA、バックエンドをREST APIを提供するアプリで作成し、ユーザーの操作に応じて必要なタイミングで連携することで、それぞれの機能を実現します。 フロントエンドのSPAを実装するためにはReactを使用し、プロジェクトの作成にはCreate React Appを使用します。開発言語にはJavaScriptをそのまま利用せず、JavaScriptを拡張したTypeScriptを使用します。 バックエンドのREST APIは、NablarchのRESTfulウェブサービスを使用して作成します。 フロントエンドとバックエンドの開発については、実際の開発プロジェクトで開発チームが分かれる可能性を考慮し、それぞれを独立して順に開発していきます。そこで、フロントエンドとバックエンドの境界となるREST APIについては、OpenAPIを用いてドキュメント化します。そうすることで、REST APIのクライアントコードやモックを自動生成できるようにし、一貫性を保ちやすくします。そのため、それぞれの機能の開発については基本的に次のステップで進めます。 REST APIのドキュメント化 フロントエンドの開発 バックエンドの開発 フロントエンドとバックエンドを結合し、End-to-End（以下E2E）で動作確認 REST API ToDo管理 ToDoを管理するため、次のREST APIを提供します。 REST APIでは、URIでリソースを表現し、HTTPメソッドでそれに対する操作を表現します。ここでは、「ToDo」をリソースとし、ToDoの集合を/todos、集合の中の1つのToDoを/todos/{id}として表現します。 また、機能や画面から、ToDoの属性として次の項目を用意します。 ToDoを識別するためのID ToDoの内容 ToDoの状態 なお、バックエンドのアプリでは、REST APIのリクエストであることを識別するため、パスを/apiで始めるルールとなるように設定します。 これらから、ToDoを操作するためのREST APIは、次のとおりとします。 HTTPメソッド パス 説明 リクエスト レスポンス GET /api/todos ToDoを全て取得する - ToDoの一覧 POST /api/todos ToDoを新しく登録する ToDoの内容 登録したToDo PUT /api/todo/{id} ToDoの状態を更新する ToDoの状態 更新したToDo DELETE /api/todo/{id} ToDoを削除する - - ユーザー認証 ユーザーを認証するためのREST APIを提供するため、REST APIを定義します。 REST APIでは状態を持たないことが基本的な考えであり、状態を扱うユーザー認証では何をリソースと捉えてどのような操作にするのかを考えるのが難しくなります。そのため、ここではリソースとそれに対する操作という基本的な考え方には則らず、実現したい操作に着目し、URIで操作を表現し、HTTPメソッドはPOSTで実行指示を表現するようにします。 これらから、ユーザー認証を行うためのREST APIは、次のとおりとします。 HTTPメソッド パス 説明 リクエスト レスポンス POST /api/signup アカウントを新しく登録する アカウント情報 - POST /api/login ログインする アカウント情報 - POST /api/logout ログアウトする - - CSRF対策 Nablarchでは、クロスサイト・リクエスト・フォージェリ（以下CSRF）に対策するための機能が提供されています。（参考：CSRF | 安全なウェブサイトの作り方） この機能は、CSRFトークンを発行してリクエスト毎にサーバーサイド側で保持してるCSRFトークンと突き合わせる方式であるため、使用するCSRFトークンを取得するためのREST APIを用意します。 HTTPメソッド パス 説明 リクエスト レスポンス GET /api/csrf_token CSRFトークンを取得する - - "},"todo-project/":{"url":"todo-project/","title":"ToDoアプリプロジェクトの作成","keywords":"","body":"ToDoアプリプロジェクトの作成 ToDoアプリを開発するためのプロジェクトを作成します。 目次 プロジェクトの作成 ハンズオン用のひな形を使用して、プロジェクトを作成します。 フロントエンドの確認 フロントエンドを開発するためのプロジェクトを確認します。 バックエンドの確認 バックエンドを開発するためのプロジェクトを確認します。 "},"todo-project/project/":{"url":"todo-project/project/","title":"プロジェクトの作成","keywords":"","body":"プロジェクトの作成 前ステップで取得したハンズオンリポジトリに含まれるプロジェクトのひな形を使用し、ToDoアプリを開発するためのプロジェクトを作成します。 プロジェクトのひな形はspa-restapi-handson/starter-kitに配置しておりますので、このディレクトリを任意の場所にコピーしてください。 コピーが完了したら、starter-kitディレクトリの名前をtodo-appに変更してください。 todo-appディレクトリの構造が、以下のとおりであることを確認します。 todo-app ├── frontend └── backend frontendはフロントエンドを開発するためのプロジェクトで、backendはバックエンドを開発するためのプロジェクトになります。 それぞれのプロジェクトについて、順に確認していきます。 "},"todo-project/frontend/":{"url":"todo-project/frontend/","title":"フロントエンドの確認","keywords":"","body":"フロントエンドの確認 フロントエンドを開発するためのプロジェクトを確認します。 フロントエンド開発プロジェクトを確認する frontendディレクトリが、フロントエンド開発プロジェクトになります。 このプロジェクトは、Create React App（以下CRA）のTypeScript用テンプレートで作成しています。（参考：CRA - Adding TypeScript） 実装を小さくするために、CRAで生成されたプロジェクトに次のような修正を加えた状態です。 開発に使用するDockerCompose定義ファイルを追加 HelloWorldを表示するだけの簡易なページに変更 ページ変更に伴う不要ファイルの削除 アプリの実行時には使用しないライブラリをpackage.jsonのdependenciesからdevDependenciesに移動 ディレクトリ構造は、次のようになっています。 frontend ├── .gitignore ├── package.json ├── tsconfig.json ├── docker │ ├── docker-compose.api-gen.yml │ └── docker-compose.api-mock.yml ├── public │ ├── favicon.ico │ └── index.html └── src ├── index.tsx ├── App.tsx ├── react-app-env.d.ts └── setupTests.ts .gitignore Gitで管理対象外とするファイルを定義するためのファイルです。 CRAでアプリ作成時に生成されたものを使用しています。 package.json フロントエンドアプリのプロジェクト定義ファイルです。 CRAでアプリ作成時に生成されたものを使用しています。 tsconfig.json TypeScript用のプロジェクト定義ファイルです。 CRAでアプリ作成時に生成されたものを使用しています。 docker/docker-compose.api-gen.yml OpenAPI定義ファイルからクライアント実装を生成するための、Docker Composeの定義ファイルです。 docker/docker-compose.api-mock.yml OpenAPI定義ファイルからモックサーバを起動するための、Docker Composeの定義ファイルです。 public/favicon.ico ファビコン用のアイコン。 CRAでアプリ作成時に生成されたものを使用しています。 public/index.html CRAで作成したアプリでページ表示のエントリポイントとなるHTMLファイルです。コンテンツは動的に生成するため、タグのみ定義しています。 Todo App src/index.tsx CRAで作成したアプリでJavaScript実行のエントリポイントとなるsrc/index.jsのTypeScript実装です。 この実装の中では、JSXと呼ばれるJavaScript構文の拡張を使用しています。JSXを使用することで、React要素をHTMLのマークアップに近しいイメージで記述することができます。（参考：React - JSX でマークアップを記述する]） なお、TypeScriptファイルの拡張子は通常tsですが、後述のJSXを使用する場合はtsxとする必要があります。（参考：TypeScript - JSX） import React from 'react'; import ReactDOM from 'react-dom/client'; import App from './App'; const container = document.getElementById('root'); const root = ReactDOM.createRoot(container!); root.render( ); ReactDOM.createRoot()を使用してアプリのルートコンポーネントを作成しています。（参考：createRoot） ReactDOM.createRoot()の引数にはレンダー先のDOM要素を指定します。ここではDocument.getElementById()の実行結果を渡しています。 ここでのdocumentは前述のpublic/index.htmlを指しており、そこで定義されているを表すDOMに、引数に渡したReact要素がレンダーされることになります。 public/index.htmlのにはしか無いため、コンテンツを全て更新していることになります。 root.render()を使用してReactコンポーネントを指定されたDOMにレンダリングします。（参考：root.render(reactNode)） root.render()の引数にはReactコンポーネントを指定します。ここでは、上で説明したJSXを使用して、とその子要素にがあるReact要素を定義しています。 はReact.StrictModeのコンポーネントを指しており、React.StrictModeコンポーネントはReactが提供するコンポーネントです。このコンポーネントは、子要素でReactのstrictモードを有効にするためのコンポーネントになります。出力されるページのコンテンツには影響しませんが、開発時に有用となる警告等を表示してくれるようになります。（参考：StrictMode） 同様に、はAppコンポーネントを指しています。このコンポーネントについては後述します。 src/App.tsx Appコンポーネントを実装しています。このコンポーネントは、Hello, worldというHTML要素を表すReact要素を返します。 import React from 'react'; function App() { return ( Hello, world ); } export default App; src/react-app-env.d.ts TypeScript用の定義ファイルです。 CRAでアプリ作成時に生成されたものを使用しています。 src/setupTests.ts テスト用の定義ファイルです。 CRAでアプリ作成時に生成されたものを使用しています。 フロントエンドのアプリを起動する CRAでは、開発モードとしてアプリを起動することができます。（参考：CRA - Available Scripts） まず、依存モジュールをインストールするため、frontendディレクトリで次のコマンドを実行します。実行時にはいくつかの警告（npm WARN 〜）が出力されますが、ここでは無視してください。 $ npm install 続いて、アプリを起動するため次のコマンドを実行します。 $ npm start 起動が完了したら、自動的にデフォルトブラウザでトップページが開きますので、次の画面が表示されていることを確認します。 起動中はコマンドが実行中のままになりますので、確認が完了したら、Ctrl+Cで終了します。 "},"todo/":{"url":"todo/","title":"ToDo管理の実装","keywords":"","body":"ToDo管理の実装 ToDoページでToDoの管理をできるようにするため、ToDoページとToDo管理機能を実装していきます。 目次 フロントエンド ToDo管理のフロントエンドを実装します。 バックエンド ToDo管理のバックエンドを実装します。 動作確認 フロントエンドとバックエンドを接続して動作を確認します。 "},"todo/frontend/":{"url":"todo/frontend/","title":"フロントエンド","keywords":"","body":"フロントエンド ToDo管理のフロントエンドを、次の順で実装していきます。 目次 ページ外観の作成 ToDoページの外観を作成します。 コンポーネントの分割 ToDoページをコンポーネントに分割します。 REST APIクライアントの作成 REST APIクライアントコードを使用する準備として、クライアントコードをラッピングしたオブジェクトを作成します。 CORSの設定 バックエンドのREST APIにアクセスできるようにするため、CORSを設定します。 モックサーバの起動 OpenAPIドキュメントを使用してモックサーバを起動し、REST APIの呼び出しをテストできるようにします。 ToDoの一覧表示 ToDoページで登録されているToDoを一覧表示できるように実装します。 ToDoの登録 ToDoページで新しいToDoを登録できるように実装します。 ToDo状態の更新 ToDoページでToDoの状態を更新できるように実装します。 ToDo一覧の絞り込み ToDoページで表示されるToDoを絞り込みできるように実装します。 "},"todo/frontend/todo-page/":{"url":"todo/frontend/todo-page/","title":"ページ外観の作成","keywords":"","body":"ページ外観の作成 ToDoページの外観を作成します。 ToDoページの表示 まず、フロントエンドのアプリでデザインモックと同様のページを表示できることを確認します。 前述のとおり、Todoアプリのデザインモックはspa-restapi-handson/design-mockに配置しており、その中のtodo.htmlとtodo.cssがTodoページのデザインモックになります。デザインモックを確認すると、以下のような画面デザインになっています。 現時点ではAppコンポーネントのみ作成されており、Hello, worldを返しています。これを置き換え、デザインモックのHTMLと同等のReact要素を返すようにします。デザインモックからHTMLのbody部を抽出し、JSXでReact要素を定義します。 その前に、確認をしやすいようにアプリを起動しておきます。起動中はファイルの状態が監視され、ファイルが更新されると即座にコンパイルしてページに反映してくれるため、エラーがあった場合にもすぐに確認することができます。 アプリを起動するには、起動テストの時と同様、次のコマンドを実行します。 $ npm start アプリが起動したら、AppにJSXを記述していきます。HTMLを確認しながら順にJSXを記述していくこともできますが、ここでは、デザインモックのHTMLのbody部をそのまま持ってきて同じように表示できることをまず確認してみます。また、HTMLをそのまま持ってきた際に、HTMLとJSXの違いによりいくつかのエラーが発生しますので、それについても確認していきます。 それでは、ToDoページのデザインモックであるtodo.htmlのbody部をコピーして、AppのJSXとしてそのまま持ってきます。 function App() { return ( ... ); } すると、次のようなエラーが発生します。 Failed to compile. ./src/App.tsx SyntaxError: Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...? エラーメッセージを確認すると、JSXは必ず1の親要素を持つ必要がある、とあります。これは、JSXではトップレベルの要素として複数の要素を返すことはできず、必ず1つの要素として返さなければいけないためです。デザインモックのHTMLをそのまま持ってくると、headerタグとdivタグがトップレベルで並んだ状態になるため、このルールに違反してしまいます。ダミーの親要素として等で囲って返すといったこともできますが、意味を持たない余分な要素をページに出力することになってしまいます。そのため、ここではフラグメントというReactが提供するコンポーネントを使用します。次のようにReact要素のトップレベルで使用することで、出力結果には影響させずに、複数の要素を1つの要素として返すことができます。 function App() { return ( ... ); } このエラーを解消すると、次のようなエラーが発生します。 Failed to compile. /Users/xxx/work/todo-app/frontend/src/App.tsx TypeScript error in /Users/xxx/work/todo-app/frontend/src/App.tsx(15,15): Type '{ children: Element[]; class: string; }' is not assignable to type 'DetailedHTMLProps, HTMLElement>'. Property 'class' does not exist on type 'DetailedHTMLProps, HTMLElement>'. TS2322 13 | return ( 14 | > 15 | | ^ 16 | Todoアプリ 17 | 18 | エラーメッセージを確認すると、classプロパティはその型に存在しない、とあります。これは、JSXではclass属性が無いためです。このように、JSXはHTMLと完全に同じというわけではないため、属性がそのまま使えない場合があります。JSXでは、class属性と同等の属性がclassName属性として提供されているため、次のようにclassName属性を使うように修正します。 function App() { return ( ... ); } このエラーを解消すると、最後に次のようなエラーが発生します。 /Users/xxx/work/todo-app/frontend/src/App.tsx TypeScript error in /Users/xxx/work/todo-app/frontend/src/App.tsx(44,70): Type 'string' is not assignable to type 'boolean | undefined'. TS2322 42 | 43 | > 44 | | ^ 45 | 洗い物をする 46 | 47 | これは、JSXではchecked属性にはboolean値を設定する必要があるためです。 JSXでは、中括弧で囲うことで式を埋め込むことができますので、\"checked\"と同等であるtrueを設定するよう、次のように修正します。（参考：React - 波括弧は JavaScript 世界への窓口） ちなみに、スクリプトを実行したタイミングでエラーになるのではなく、このようにコンパイルされるタイミングでエラーを検知してくれるのは、型を利用できるTypeScriptのメリットでもあります。 これらのエラーを解消した後、Appは次のようになります。 src/App.tsx import React from 'react'; function App() { return ( Todoアプリ テストユーザさん ログアウト 追加 全て 未完了のみ 完了のみ 洗い物をする x 洗濯物を干す x 買い物へ行く x ); } export default App; この状態で、エラーは発生せずにページが表示されますが、以下のようにスタイルが適用されていない状態となっています。 AppではCSSファイルを取り込む実装をしていないため、スタイルが適用されていない状態になっています。そのため、次はCSSファイルを取り込む実装を追加していきます。 CSSファイルの作成 Reactでは、スタイルの記述方法がいくつか提供されていますが、ここではデザインモックのCSSファイルを使うために、className属性とCSSファイルを使ってスタイルを定義します。（参考：React - CSS スタイルの適用） CRAに含まれるwebpackでは、importを使用してCSSファイルを読み込むことが出来るため、その方法でコンポーネントにCSSファイルを読み込みます。（参考：CRA - Adding a Stylesheet） App用のCSSのファイルとして、App.cssを作成します。CSSファイルの中身は、ToDoページのデザインモックのCSSをそのまま持ってきます。 src/App.css body { margin: 0; } .PageHeader_header { display: flex; justify-content: space-between; align-items: center; padding: 0 5%; border-bottom: solid 1px black; background: black; } .PageHeader_title { color: white; font-size: 1.5rem; } .PageHeader_header a { text-decoration: none; } .PageHeader_nav { display: flex; list-style: none; } .PageHeader_nav li { margin-left: 30px; color: white; } .PageHeader_nav a { color: white; } .PageHeader_nav button, .PageHeader_nav button:active, .PageHeader_nav button:hover { cursor: pointer; border: 0; background-color: transparent; color: white; } .TodoBoard_content { margin-top: 10px; width: 40%; padding: 0 30%; } .TodoForm_content { margin-top: 20px; margin-bottom: 20px; } .TodoForm_form { width: 100%; display: flex; justify-content: space-between; } .TodoForm_input { width: 86%; } .TodoForm_input input{ float: left; width: 95%; border-radius: 5px; padding: 8px; border: solid 1px lightgray; background-color: #fafbfc; font-size: 16px; outline: none; } .TodoForm_input input:focus { background-color: white; } .TodoForm_button { text-align: center; width: 14%; } .TodoForm_button button { height: 35px; cursor: pointer; line-height: 1; font-size: 1rem; color: white; background-color: darkgreen; border-radius: 5px; padding: 0 15px; border: none; vertical-align: middle; } .TodoForm_button button:hover { background-color: green; } .TodoFilter_content { text-align: right; } .TodoFilter_content button{ margin-left: 5px; } .TodoFilter_buttonSelected { background-color: #31b3c7; border-width: 0; color: #fff; cursor: pointer; justify-content: center; padding: 7px 16px; text-align: center; white-space: nowrap; border-radius: 290486px; outline: none; } .TodoFilter_buttonUnselected { background-color: lightgray; border-width: 0; color: gray; cursor: pointer; justify-content: center; padding: 7px 16px; text-align: center; white-space: nowrap; border-radius: 290486px; outline: none; } .TodoList_list { list-style: none; padding: 0; margin: 20px 0; } .TodoItem_item { padding: 15px 10px; background: whitesmoke; margin-bottom: 10px; } .TodoItem_todo { float: left; text-align: left; } .TodoItem_checkbox { margin-right: 7px; outline: none; } .TodoItem_delete { text-align: right; } .TodoItem_button { font-size: 17px; font-weight: bold; border: none; color: grey; background: lightgrey; border-radius: 100%; width: 25px; height: 25px; line-height: 20px; cursor: pointer; outline: none; } 作成したCSSファイルをAppコンポーネントに取り込むため、App.tsxに以下のimportを追加します。 src/App.tsx import './App.css'; ページの表示内容を確認し、スタイルが適用されてデザインモックと同等の表示内容になっていることを確認します。 これで、ページの作成は完了です。 "},"todo/frontend/api/":{"url":"todo/frontend/api/","title":"REST APIクライアントの作成","keywords":"","body":"REST APIクライアントの作成 ToDo一覧を実装する際には、バックエンドのREST APIにアクセスする必要があります。ここでは、OpenAPIドキュメントを利用してREST APIのクライアントを作成します。 OpenAPIドキュメントの確認 REST APIをOpenAPI仕様で記述したOpenAPIドキュメントは、プロジェクト作成時に作成しています。（参考：OpenAPI - Specification） バックエンドのrest-api-specification/openapi.yamlファイルがOpenAPIドキュメントになるため、内容を確認します。 例えば、ToDoの一覧を取得するためのREST APIは、次のように定義されています。 /api/todos: get: summary: ToDo一覧の取得 description: > 登録しているToDoを全て取得する。 tags: - todos operationId: getTodos responses: '200': description: OK content: application/json: schema: type: array items: $ref: '#/components/schemas/Todo' examples: example: value: - id: 2001 text: やること１ completed: true - id: 2002 text: やること２ completed: false '403': description: Forbidden summaryやdescriptionには、ドキュメント化したときの説明文を定義します。 tagsには、REST APIをグルーピングするための名前を定義します。ここでは、ToDo管理とユーザー認証のREST APIを区別するために使用します。このtagsを指定することで、OpenAPIドキュメントから様々な成果物を生成したりする際に、グルーピングされるようになります。例えば、REST APIのクライアントコードでは、tagsに指定した名前ごとにクラス（ここではTodosApi）が生成されるようになります。 operationIdには、それぞれのREST APIを一意に識別するためのIDを定義します。これはクライアントを自動生成した際の関数名にもなるため、それを考慮して定義します。 responsesには、レスポンスを定義します。responsesにはステータスコードごとに定義します。JSON形式で返却するため、contentとしてapplication/jsonを定義します。 content内のschemaには、レスポンスデータの形式を定義します。ここでは、配列を返すように定義し、配列の中については$refを使って共通で定義したコンポーネントを参照するよう定義します。複数のREST APIで扱うToDoレスポンスの形式が同じであるため、このような定義にしています。 参照先となる形式は、次のように定義しています。 components: schemas: Todo: title: Todo type: object description: ToDo情報 properties: id: type: integer description: ToDoのID text: type: string description: ToDoのタイトル completed: type: boolean description: ToDoのステータス required: - id - text - completed additionalProperties: false propertiesには、このコンポーネントの項目を定義します。全ての項目が必ず必要であるため、requiredには全ての項目を定義します。ここで定義していない項目が追加で返却されることは想定していないため、additionalPropertiesにはfalseを定義します。 content内のexamplesに、実際に返却される例を定義します。 これらから、REST APIで返却されるJSONは、次のようなイメージになります。 { [ { \"id\": 2001, \"text\": \"やること１\", \"completed\": true }, { \"id\": 2002, \"text\": \"やること２\", \"completed\": false } ] } クライアントコードの生成 REST APIのクライアントコードを、OpenAPIドキュメントから生成します。 クライアントコードの生成には、OpenAPI Generatorを使用します。OpenAPIが提供しているツールで、OpenAPIドキュメントから様々なものを生成することができます。TypeScript用のクライアントコードについても様々な実装を生成することができますが、ここではtypescript-fetchを使用します。 OpenAPI Generatorはコンテナイメージでも提供されています。そのコンテナイメージを使用して実行するためのDocker Composeファイルとしてdocker-compose.api-gen.ymlを予め作成しているため、Docker Composeを使用してDockerコンテナ上で生成します。 frontendディレクトリで、次のコマンドを実行します。 $ docker-compose -f docker/docker-compose.api-gen.yml up 実行が完了すると、srcの下にbackendディレクトリが生成され、その配下にgenerated-rest-clientディレクトリが生成されます。このgenerated-rest-client配下に、自動生成されたクライアントコードが格納されています。 フロントエンドでREST APIを呼び出す際には、このクライアントコードを使用していきます。 クライアントコードのラッパーを作成 OpenAPIドキュメントからREST APIのクライアントコードを生成しましたが、使用時には同じ設定を行うことが多くなります。そこで、共通的な設定がされたクライアントコードを使用するために、生成したクライアントコードをラッピングしたBackendSerivceを作成します。コンポーネントからREST APIにアクセスする際には、生成したクライアントコードは直接使用せずに、このBackendSerivceを使用するようにします。 src/backendディレクトリにBackendService.tsを作成します。 src/backend/BackendService.ts import { Configuration, TodosApi, Middleware, UsersApi } from './generated-rest-client'; const requestLogger: Middleware = { pre: async (context) => { console.log(`>> ${context.init.method} ${context.url}`, context.init); }, post: async (context) => { console.log(` { return usersApi.signup({ inlineObject2 : { userName, password }}); }; const login = async (userName: string, password: string) => { return usersApi.login({ inlineObject3: { userName, password }}); }; const logout = async () => { return usersApi.logout(); }; const getTodos = async () => { return todosApi.getTodos(); }; const postTodo = async (text: string) => { return todosApi.postTodo({ inlineObject: { text }}); }; const putTodo = async (todoId: number, completed: boolean) => { return todosApi.putTodo({ todoId, inlineObject1: { completed }}); }; export const BackendService = { signup, login, logout, getTodos, postTodo, putTodo }; 生成されたクライアントコードでは、REST APIを呼び出すためにはTodosApi等のAPIクラスのオブジェクトを生成する必要があります。生成時には設定オブジェクトを渡すことで、様々な設定をすることができます。 生成したクライアントコードでは、Middlewareと呼ばれる部品を作成することで、リクエストやレスポンスに対する共通的な処理を実装することができます。ここでは、開発時にREST APIの呼び出しを確認しやすいように、リクエストとレスポンスをコンソールにログ出力するMiddlewareを作成します。 なお、OpenAPIドキュメントにはToDoを削除するためのREST APIも定義されていますが、削除については後の演習にて自身で実装できるよう、ここでは作成しません。 "},"todo/frontend/cors/":{"url":"todo/frontend/cors/","title":"CORSの設定","keywords":"","body":"CORSの設定 ToDoアプリでは、フロントエンドとバックエンドを別々のアプリとして作成します。フロントエンドアプリはhttp://localhost:3000、バックエンドアプリはhttp://localhost:9080で起動するため、ウェブコンテンツとしては異なるオリジンということになります。（オリジン | MDN） セキュリティ上の理由から、ブラウザでは異なるオリジンへのリクエストを制限しています。（参考：同一オリジンポリシー | MDN） この制限により、そのままではフロントエンドアプリからバックエンドアプリのREST APIにアクセスしようとするとエラーが発生してしまいます。 この制限に対応するため、ToDoアプリでは、オリジン間リソース共有（以下CORS）と呼ばれる仕組みを利用します。（参考：オリジン間リソース共有 (CORS) | MDN） 生成したクライアントコードでは、Fetch APIを使用してHTTP通信を行います。このAPIでは、リクエストを送信するためのfetch()メソッドの引数であるinitオブジェクトに次の値を設定することで、CORSを使用することができます。（リクエストにオプションを適用する | MDN） { mode: 'cors', credentials: 'include' } 先ほど作成したBackendServiceでこの設定をするため、次のように実装します。リクエスト時にmodeとcredentialsが設定されるように、corsHandlerをMiddlewareとして実装します。実装したcorsHandlerを使用するために、configurationオブジェクトのmiddlewareに追加します。 const corsHandler: Middleware = { pre: async (context) => { return { url: context.url, init: { ...context.init, mode: 'cors', credentials: 'include' } }; } }; const configuration = new Configuration({ middleware: [corsHandler, requestLogger] }); これで、フロントエンドのCORS設定については完了です。 "},"todo/frontend/mock/":{"url":"todo/frontend/mock/","title":"モックサーバの起動","keywords":"","body":"モックサーバの起動 この時点では、まだバックエンドのREST APIの開発は完了していないため、そのままではREST APIを呼び出すことができません。そこで、OpenAPIドキュメントを使用してモックサーバを起動し、REST APIを呼び出せるようにします。 モックサーバにはPrismを使用します。PrismはOSSのモック&プロキシサーバで、OpenAPIドキュメントを使用してモックサーバを起動することができます。 Prismはコンテナイメージでも提供されています。そのコンテナイメージを使用して実行するためのDocker Composeファイルとしてdocker-compose.api-mock.ymlを予め作成しているため、Docker Composeを使用してDockerコンテナ上でモックサーバを起動します。 frontendディレクトリで、次のコマンドを実行します。なお、ここでは実行結果を確認しやすいよう、バックグラウンドで起動するためのパラメータである-dは付けずに実行します。 $ docker-compose -f docker/docker-compose.api-mock.yml up 次のようにstart Prism is listeningといった出力がされていれば、起動が完了しています。 prism_1 | [9:54:45 PM] › [CLI] … awaiting Starting Prism… prism_1 | [9:54:47 PM] › [CLI] ℹ info GET http://0.0.0.0:9080/api/todos prism_1 | [9:54:47 PM] › [CLI] ℹ info POST http://0.0.0.0:9080/api/todos prism_1 | [9:54:47 PM] › [CLI] ℹ info PUT http://0.0.0.0:9080/api/todos/401.33348794918277 prism_1 | [9:54:47 PM] › [CLI] ℹ info DELETE http://0.0.0.0:9080/api/todos/170.16709317551496 prism_1 | [9:54:47 PM] › [CLI] ℹ info POST http://0.0.0.0:9080/api/signup prism_1 | [9:54:47 PM] › [CLI] ℹ info POST http://0.0.0.0:9080/api/login prism_1 | [9:54:47 PM] › [CLI] ℹ info POST http://0.0.0.0:9080/api/logout prism_1 | [9:54:47 PM] › [CLI] ℹ info GET http://0.0.0.0:9080/api/csrf_token prism_1 | [9:54:47 PM] › [CLI] ▶ start Prism is listening on http://0.0.0.0:9080 動作を確認するため、ブラウザを起動し、localhost:9080/api/todosにアクセスします。 Prismでは、レスポンスとしてOpenAPIドキュメントに定義されたexampleを使用するため、次のレスポンスが画面上に出力されることを確認します。（examplesを使用せずに動的に生成するDynamic Response Generation機能もあります） [ - { id: 2001, text: \"やること１\", completed: true }, - { id: 2002, text: \"やること２\", completed: false } ] Prismでは、リクエストを受信すると、ログをコンソールに出力します。/api/todosに対するGETリクエストを受信しているため、次のような内容が出力されています。 ism_1 | [4:29:54 AM] › [HTTP SERVER] get /api/todos ℹ info Request received prism_1 | [4:29:54 AM] › [NEGOTIATOR] ℹ info Request contains an accept header: */* prism_1 | [4:29:54 AM] › [VALIDATOR] ✔ success The request passed the validation rules. Looking for the best response prism_1 | [4:29:54 AM] › [NEGOTIATOR] ✔ success Found a compatible content for */* prism_1 | [4:29:54 AM] › [NEGOTIATOR] ✔ success Responding with the requested status code 200 なお、モックサーバを停止させる場合には、起動したコンソールでCtrl+Cを押します。 これでモックサーバの起動は完了です。 "},"todo/frontend/todo-list/":{"url":"todo/frontend/todo-list/","title":"ToDoの一覧表示","keywords":"","body":"ToDoの一覧表示 ToDoページで登録されているToDoを一覧表示できるように実装します。 stateの設計 登録されているToDoを表示するために、コンポーネントでどのような状態が必要になるかを考えていきます。 Reactでは、stateを使用することで、状態の変化を表現することができます。（参考：React - Reactの流儀 ステップ 3） コンポーネントのstateになりうるのは、ユーザーからの入力や時間の経過の中で変化したり、他のstate等を使って算出可能ではないものになります。画面に表示するToDoの一覧は、ユーザーからの入力で変化していくもので、算出することもできないため、stateとします。 次に、そのstateをどのコンポーネントに配置するのかを考えていきます。（参考：React - Reactの流儀 ステップ 4） このstateを表示するためのコンポーネントは、TodoListになります。TodoItemではそれぞれのToDoの内容を表示しますが、一覧できるように表示するのはTodoListです。また、TodoFormではこのToDo一覧に追加することができるため、TodoFormでもこのstateを扱うことになります。複数のコンポーネントでstateを必要とする場合、階層構造の中で共通の親コンポーネントがstateを持つことが適しているため、ここでは、TodoBoardにこのstateを持たせることにします。 コンポーネントの実装 現時点では、ToDoの表示内容はTodoListに静的に定義していますが、これをTodoBoardでstateを使って実装します。 Reactの関数コンポーネントでは、様々な機能を実装するためにフック（Hooks）と呼ばれる様々な機能が提供されており、useStateフックを使います。（参考） useStateフックはuseStateを呼び出すことで使用できます。引数に初期値を指定し、返り値としてstateとそれを更新するための関数をペアで返します。例えば、0から始まるカウントをstateとし、ボタンをクリックするごとにstateを更新するような場合、次のように使用します。 const [count, setCount] = useState(0); return ( {count} setCount(count + 1)}>カウントアップ ); ここでは、初期値としてはまず現在の静的なデータを使用しておきます。合わせて、REST APIで取得した際にはToDoを識別するidも返却されるため、これも追加しておきます。 stateの更新は今の段階では必要ないため、stateを次のように実装します。 const [todos] = useState([ { id: 2001, text: '洗い物をする', completed: true }, { id: 2002, text: '洗濯物を干す', completed: false }, { id: 2003, text: '買い物へ行く', completed: false } ]); このstateをTodoBoardに配置し、TodoListで表示するため、TodoListでもTodoItemと同様にプロパティを定義し、TodoBoardからstateを受け取るようにする必要があります。TodoItemと同様にtypeでプロパティの型を定義して、TodoListにプロパティを追加します。 また、先ほどstateで扱うToDoデータにidを追加したため、プロパティでToDoデータを受け取っているコンポーネントの型定義に、次のようにidを追加しておきます。 type Props = { id: number text: string completed: boolean } また、state使用前はTodoListで静的データを定義していたため、TodoList内でTodoItemを固定で3つ定義していましたが、プロパティとして引数で受け取るようにしたことで、定義するTodoItemの数が動的になります。引数は配列で受け取るため、mapを使用して動的にTodoItemを生成するようにしておきます。 これらを実装すると、TodoBoardとTodoList、TodoItemは次のとおりになります。 src/components/TodoBoard.tsx import React, { useState } from 'react'; import './TodoBoard.css'; import { TodoForm } from './TodoForm'; import { TodoFilter } from './TodoFilter'; import { TodoList } from './TodoList'; type Todo = { id: number text: string completed: boolean } export const TodoBoard: React.FC = () => { const [todos] = useState([ { id: 2001, text: '洗い物をする', completed: true }, { id: 2002, text: '洗濯物を干す', completed: false }, { id: 2003, text: '買い物へ行く', completed: false } ]); return ( ); }; src/components/TodoList.tsx import React from 'react'; import './TodoList.css'; import { TodoItem } from './TodoItem'; type Todo = { id: number text: string completed: boolean } type Props = { todos: Todo[] } export const TodoList: React.FC = ({todos}) => { return ( {todos.map(todo => )} ); }; src/components/TodoItem.tsx import React from 'react'; import './TodoItem.css'; type Props = { id: number text: string completed: boolean } export const TodoItem: React.FC = ({id, text, completed}) => { return ( {text} x ); }; なお、TodoListのJSXでTodoItemを宣言しているところで、keyプロパティを使用します。これは、コンポーネントのレンダリング要否を判定するためにReactが使うプロパティで、mapで繰り返してコンポーネントを使用したりする場合、個々のコンポーネントを識別するために一意となる値を設定しておきます。（参考：React - リストのレンダー） REST APIの呼び出しとstateの更新 次に、stateを更新するため、REST APIを呼び出すタイミングを考えます。 ページを表示したタイミングでToDo一覧を表示したいので、TodoBoardコンポーネントを最初にレンダーしたタイミングで、REST APIを呼び出し、その結果からstateを更新するようにします。 関数コンポーネントでは、このようにデータの取得や更新によりコンポーネントに影響を与えることを副作用と呼び、副作用を起こす処理を実装するためのフックとして、useEffectフックが提供されています。（参考：React - useEffect） useEffectフックはuseEffectを呼び出すことで使用します。第1引数に副作用を起こす関数と、第2引数にこの副作用が依存するstateを配列で渡します。第2引数に渡したstateが更新されると、第1引数の関数が実行されます。ここでのREST API呼び出しは他のstateに依存せず、最初のレンダー後に呼び出したいため、そのような場合には空の配列（[]）を渡します。（参考：React - エフェクトの依存配列を指定する（落とし穴）） useStateフックの初期値で静的データを渡していましたが、REST APIの呼び出しを想定し、まずはuseEffectフックを使用して静的データでstateを更新するように実装してみます。stateの初期値としては、空の配列を渡しておきます。 src/components/TodoBoard.tsx import React, { useEffect, useState } from 'react'; import './TodoBoard.css'; import { TodoForm } from './TodoForm'; import { TodoFilter } from './TodoFilter'; import { TodoList } from './TodoList'; type Todo = { id: number text: string completed: boolean } export const TodoBoard: React.FC = () => { const [todos, setTodos] = useState([]); useEffect(() => { setTodos([ { id: 2001, text: '洗い物をする', completed: true }, { id: 2002, text: '洗濯物を干す', completed: false }, { id: 2003, text: '買い物へ行く', completed: false } ]); }, []); return ( ); }; ページの表示内容を確認すると、何も変わらず表示されています。いまは静的データで設定しているだけでuseEffectの処理も瞬時に完了するため、目に見えるような影響はありません。 useEffectフックで更新する準備ができたため、次に、生成したクライアントコードを使用してREST APIを呼び出すように実装します。事前に作成したBackendServiceの関数を使用して、REST APIを呼び出します。結果はPromiseで返ってくるため、thenを呼び出してレスポンスが返ってきたタイミングでstateの更新関数を呼び出すように実装します。 import React, { useEffect, useState } from 'react'; import './TodoBoard.css'; import { TodoForm } from './TodoForm'; import { TodoFilter } from './TodoFilter'; import { TodoList } from './TodoList'; import { BackendService } from '../backend/BackendService'; type Todo = { id: number text: string completed: boolean } export const TodoBoard: React.FC = () => { const [todos, setTodos] = useState([]); useEffect(() => { BackendService.getTodos() .then(response => setTodos(response)); }, []); return ( ); }; モックを使用した動作確認 ページを表示したら、モックサーバから取得したデータが一覧で表示されることを確認します。 確認ができたら、フロントエンドの実装は完了です。 "},"todo/frontend/todo-add/":{"url":"todo/frontend/todo-add/","title":"ToDoの登録","keywords":"","body":"ToDoの登録 ToDoページで新しいToDoを登録できるように実装します。 stateの設計 ToDoの一覧表示の時と同様に、ToDoを登録するコンポーネントで、どのような状態が必要になるかを考えていきます。 ここでは、ToDoを登録するためのフォームを作成します。フォームの作成についてはReactからガイドされており、フォーム自身が保持する独自のstateをReactが管理するstateに統合し、Reactのstateのみで制御する「制御されたコンポーネント」として作成することを推奨しています。（参考：input、select、textarea） ここからわかるとおり、フォームでは入力中の状態を保持するstateが必要になります。ここでは、ToDoの内容を入力するフォームであるため、入力中のToDoの内容を保持するstateが必要になります。 このstateは、ToDoを登録するコンポーネントであるTodoFormでしか必要ないため、stateはこのコンポーネントに配置します。 登録完了したToDoは一覧に表示しますが、一覧で表示するためのToDoを保持するstateはTodoBoardに配置しています。そのため、TodoFormでToDoを登録した際にTodoBoardのstateを更新するようにします。 ToDo登録フォームの実装 TodoFormを実装していきます。このコンポーネントにあるフォームには、テキスト入力ボックスがあります。これを先ほど説明した「制御されたコンポーネント」として実装します。 このようなテキスト入力ボックスを実装するために、example-chatのフロントエンドではuseInputという独自のフックを実装していますので、その実装を流用します。 まず、src/hooksディレクトリを作成し、そこにuseInput.tsファイルを作成します。 example-chatのsrc/framework/hooks/index.tsにuseInputが定義されているため、このコードをuseInput.tsファイルに持ってきます。 import { useState } from 'react'; /** * input要素のステートフックとステート更新をラッピングした独自フック。 * * @param initialState 初期値 * @return [input要素のステート, input要素の属性, ステート更新の関数] */ export const useInput = (initialState: string = ''): [string, React.InputHTMLAttributes, React.Dispatch>] => { const [value, setValue] = useState(initialState); const onChange = (event: React.FormEvent) => { setValue(event.currentTarget.value); }; return [ value, { value, onChange }, setValue ]; }; TodoFormでは、このuseInputを使用して、次のように実装します。 import React from 'react'; import './TodoForm.css'; import { useInput } from '../hooks/useInput'; export const TodoForm: React.FC = () => { const [text, textAttributes, setText] = useInput(''); const handleSubmit = (event: React.FormEvent) => { event.preventDefault(); // 登録した際の処理を書く予定だが、この時点で動作確認しやすいように一旦 alert で入力値を表示する alert(text); }; return ( 追加 ); }; useInputでは、useStateと同様に呼び出し時に初期値を渡します。戻り値としては、state自体や、inputに渡すためのプロパティが設定されたオブジェクト等が返されます。 inputのプロパティを個別に設定してもよいですが、ここではスプレッド構文を使用して、そのオブジェクトに設定されているプロパティを展開して一気に設定します。 textAttributesにはvalueとonChangeプロパティがあるため、これは次の実装と同じ意味になります。 フォームのサブミットで登録処理を行うように、「追加」ボタンのtypeをsubmitに設定します。これで、「追加」ボタンをクリックするとサブミットされるようになります。 サブミット時に登録処理を実行するようにするため、登録処理をhandleSubmit関数として実装し、formのonSubmitに設定します。これで、サブミット時にこの関数がコールバックされます。 また、サブミット時に関数がコールバックされた後、そのままだとサブミットイベントによりフォームをサーバに送信しようとしてしまうので、次のように関数内でevent.preventDefault()を呼び、サブミットイベントをキャンセルしておきます。 const handleSubmit = (event: React.FormEvent) => { event.preventDefault(); ... サブミットイベントをキャンセルすると何も起きなくなるため、この時点で動作確認をしたい場合には少し分かりづらくなります。そのため、ここでは一旦 alert で入力値を表示するようにしています。これはあくまで一時的な確認用のため、この後でREST APIを呼び出す処理を実装する際には削除します。 REST APIの呼び出しとstateの更新 先ほど作成したサブミット用のコールバック関数では、イベントをキャンセルするだけでしたが、生成したクライアントコードでREST APIを呼び出すように実装していきます。 REST APIを呼び出すと登録した結果のToDoがレスポンスとして返されるので、それを一覧に表示されるようにします。ただ、一覧に表示するためのstateは、TodoFormの親コンポーネントであるTodoBoardに配置しているため、TodoFormの実装では更新することができません。このような場合、stateを配置しているコンポーネントでstateを更新するためのコールバック関数を定義し、それをプロパティで渡してもらうようにします。 また、ToDoを登録した後は入力したテキストもクリアするため、テキスト入力のstateも更新するようにします。 import React from 'react'; import './TodoForm.css'; import { useInput } from '../hooks/useInput'; import { BackendService } from '../backend/BackendService'; type Todo = { id: number text: string completed: boolean } type Props = { addTodo: (todo: Todo) => void } export const TodoForm: React.FC = ({addTodo}) => { const [text, textAttributes, setText] = useInput(''); const handleSubmit = (event: React.FormEvent) => { event.preventDefault(); if (!text) { return; } BackendService.postTodo(text) .then(response => addTodo(response)); setText(''); }; return ( 追加 ); }; TodoBoardでは、次のように、引数のToDoをstateのToDoに結合させる関数を作成し、それをTodoFormに渡すように実装します。 export const TodoBoard: React.FC = () => { ... const addTodo = (todo: Todo) => { setTodos(todos.concat(todo)); }; ... return ( ... このようにすることで、TodoBoardのstateの管理はTodoBoardに残したまま、TodoFormから更新することができるようになります。 モックを使用した動作確認 ToDoページを表示して、ToDoが登録できることを確認します。ToDo登録フォームのテキスト入力に適当な値を入力して「追加」ボタンをクリックし、モックサーバからのレスポンスで取得したToDoが一覧に追加されるのを確認します。 モックサーバの起動時にも説明しましたが、モックサーバからはOpenAPIドキュメントのexampleに設定した値がレスポンスとして返されます。そのため、ここでは常に同じToDoが追加されることになり、実際に入力したToDoが追加されるわけではありませんので、注意してください。 確認ができたら、フロントエンドの実装は完了です。 "},"todo/frontend/todo-update/":{"url":"todo/frontend/todo-update/","title":"ToDo状態の更新","keywords":"","body":"ToDo状態の更新 ToDoページでToDoの状態を更新できるように実装します。 stateの設計 ToDoの状態を更新するコンポーネントで、どのような状態が必要になるかを考えていきます。 ToDoの状態を更新するためのチェックボックスがあるコンポーネントは、TodoItemです。 チェックするToDoのstateはTodoBoardに配置しているため、ToDoの登録と同じように、TodoBoardから更新用のコールバック関数をプロパティで渡すようにします。 REST APIの呼び出しとstateの更新 登録のときと同様に、stateの更新用のコールバック関数をプロパティで渡すように実装します。 登録のときは、TodoFormでREST APIを呼び出した後に、結果をコールバック関数に渡して実行していました。TodoFormでの実装は簡易さを重視してそのようにしましたが、ToDoのstateと更新処理は関連が深く、本来は近いところにある方が望ましくもあります。そのため、ここではTodoBoardで実装する関数内でREST APIの呼び出しも行うようにします。 TodoItemの実装 TodoItemでは、TodoListからチェックがされるたびに状態を反転して更新する関数を受け取るようプロパティを追加します。受け取った関数はチェックされるたびに実行したいため、チェックボックスのonChangeで実行するようにします。 import React from 'react'; import './TodoItem.css'; type Props = { id: number text: string completed: boolean toggleTodoCompletion: (id: number) => void } export const TodoItem: React.FC = ({id, text, completed, toggleTodoCompletion}) => { return ( toggleTodoCompletion(id)} /> {text} x ); }; TodoListの実装 TodoListでも、同様に関数を受け取るためのプロパティを追加します。受け取った関数はTodoItemにそのまま渡すようにします。 import React from 'react'; import './TodoList.css'; import { TodoItem } from './TodoItem'; type Todo = { id: number text: string completed: boolean } type Props = { todos: Todo[], toggleTodoCompletion: (id: number) => void } export const TodoList: React.FC = ({todos, toggleTodoCompletion}) => { return ( {todos.map(todo => )} ); }; TodoBoardの実装 TodoBoardでは、ToDoの状態を更新するREST APIを呼び出し、その結果からstateを更新する関数を定義します。その関数は、先ほど追加したTodoListのプロパティに渡します。 export const TodoBoard: React.FC = () => { ... const toggleTodoCompletion = (id: number) => { const target = todos.find(todo => todo.id === id); if (!target) { return; } BackendService.putTodo(id, !target.completed) .then(response => setTodos( todos.map(todo => todo.id === response.id ? response : todo) )); }; return ( ... ... addTodoとは違い、ToDoの更新手段についてもTodoBoardまで引き上げた形になりました。 モックを使用した動作確認 ToDoページを表示して、チェックボックスをクリックしてToDoを完了にできるか確認します。OpenAPIドキュメントのexampleにはidが2002で定義しているため、二行目の「やること２」のチェックボックスにチェックを入れることができるかどうかを確認します。 確認ができたら、フロントエンドの実装は完了です。 "},"todo/frontend/todo-filter/":{"url":"todo/frontend/todo-filter/","title":"ToDo一覧の絞り込み","keywords":"","body":"ToDo一覧の絞り込み ToDoページで表示されるToDoを絞り込みできるように実装します。 stateの設計 ToDoの表示対象を絞り込むために、どのようなstateが必要になるかを考えていきます。 ボタンを押すとどれか1つが選択された状態にするため、どのボタンが選択されているかのstateは必要そうです。 他に、絞り込んだ後のToDoの一覧は、stateとして保持する必要があるかを考えます。これは、全てのToDoを保持するstateと、どのボタンが選択されているかのstateで算出可能なため、stateにはなりません。（参考：React - Reactの流儀 ステップ 3） TodoBoardのstateを使用して算出するためには、どのボタンが選択されているかのstateも、TodoFilterではなくTodoBoardまで引き上げた方が簡単そうです。 コンポーネントの実装 コンポーネントの実装では、TypeScriptの型を利用した実装にしていきます。 TodoFilterの実装 表示対象を選択するボタンを表示するTodoFilterコンポーネントを実装します。stateの設計であったとおり、現在どのボタンが押されているかはをTodoBoardにstateとして保持させます。そのため、ここではプロパティでstateと更新関数を受け取るようにします。 また、TodoBoardで管理した場合、TodoBoardでもどういったボタンがあるかを知っている必要があります。ただし、どういうボタンがあるかはTodoFilterが決めるため、TodoFilterで選択可能な種類をTodoBoardに知らせるため、型として宣言することにします。 import React from 'react'; import './TodoFilter.css'; export type FilterType = 'ALL' | 'INCOMPLETE' | 'COMPLETED'; type Props = { filterType: FilterType setFilterType: (filter: FilterType) => void } export const TodoFilter: React.FC = ({filterType, setFilterType}) => { return ( setFilterType('ALL')}> 全て setFilterType('INCOMPLETE')}> 未完了のみ setFilterType('COMPLETED')}> 完了のみ ); }; このコンポーネントで扱う種類を知らせるため、次のようにFilterTypeという型を宣言し、exportしています。 export type FilterType = 'ALL' | 'INCOMPLETE' | 'COMPLETED'; これはUnion Types（共用体型）と呼ばれるTypeScriptの型で、型を|で区切ると、その型のどれか（or条件）が代入可能になります。（参考：TypeScript - Union Types） ここでは、このUnion Typesと固定の文字列を組み合わせることで、FilterType型にはこの文字列のどれかのみ代入することが可能にしています。 TodoBoardではこの型を使用することで、間違いなくTodoFilterが受け入れられる値を使用することができます。もしこれらの文字列以外を代入しようとするとコンパイルエラーになるため、TodoBoard側のミスを防いだり、FilterTypeで種類が変わって問題が発生した場合等にコンパイルエラーで検知できるようになります。 TodoBoardの実装 続いて、TodoBoardを実装します。ここでは、先ほど実装したFilterType型のstateを配置し、現在どれが選択されているかを保持するようにします。 現在保持されているFilterTypeのstateにより、TodoListにToDoデータを渡す前にフィルタ処理を行い、絞り込んだ後のToDoデータをTodoListのプロパティに渡すようにします。 import { FilterType, TodoFilter } from './TodoFilter'; ... type ShowFilter = { [K in FilterType]: (todo: Todo) => boolean } const showFilter: ShowFilter = { ALL: (todo) => true, INCOMPLETE: (todo) => !todo.completed, COMPLETED: (todo) => todo.completed, }; ... export const TodoBoard: React.FC = () => { const [todos, setTodos] = useState([]); const [filterType, setFilterType] = useState('ALL'); ... const showTodos = todos.filter(showFilter[filterType]); return ( ); }; ここでは、TodoFilterが定義しているFilterType型に対応したフィルタ処理を必ず宣言するように、次のような型を定義しています。 type ShowFilter = { [K in FilterType]: (todo: Todo) => boolean } これは、Mapped typesと呼ばれるTypeScriptの型で、オブジェクトのプロパティ名や値の型を制限することができます。[K in FilterType]部分はオブジェクトのプロパティ名の型を表しています。Kは型引数であり、ここではFilterTypeに含まれる文字列のどれかがプロパティ名として使用できるようにしています。: (todo: Todo) => boolean部分は、プロパティ値の型を表しています。 この型を使い、ボタンの種類に対応するフィルタ関数を定義したオブジェクトを生成しています。 const showFilter: ShowFilter = { ALL: (todo) => true, INCOMPLETE: (todo) => !todo.completed, COMPLETED: (todo) => todo.completed, }; 先ほどの型により、ここでのプロパティ名にはFilterTypeに代入可能な文字列のどれかである必要があり、それ以外のプロパティ名であればコンパイルエラーになります。そのため、確実にボタンの種類に対応しているフィルタ関数を宣言されるようにしています。 ここで定義したFilterTypeに対応した関数を使用するため、次のように宣言しています。現在のstateに応じたフィルタ関数が取得され、filterに適用されるようにしています。 const showTodos = todos.filter(showFilter[filterType]); 動作確認 フロントエンドのみで実装しているため、バックエンドと接続する必要はありません。フロントエンドアプリを起動し、ToDoページが表示されたら、ボタンをクリックしてToDo一覧を絞り込んで表示することができることを確認します。 確認できたら、フロントエンドの開発は完了です。 "},"todo/backend/":{"url":"todo/backend/","title":"バックエンド","keywords":"","body":"バックエンド ToDo管理のバックエンドを、次の順で実装していきます。 目次 ToDo一覧取得のREST API ToDoの一覧を取得するために使用するREST APIを実装します。 ToDo登録のREST API ToDoを登録するために使用するREST APIを実装します。 ToDo状態更新のREST API ToDoの状態を更新するために使用するREST APIを実装します。 CORSの設定 フロントエンドからREST APIにアクセスできるようにするため、CORSを設定します。 "},"todo/backend/todo-add/":{"url":"todo/backend/todo-add/","title":"ToDo登録のREST API","keywords":"","body":"ToDo登録のREST API ToDoを登録するために使用するREST APIを実装します。 ToDoを登録する処理の実装 まず、ToDoを登録する処理を実装します。ここはREST APIと直接関係が無い部分であるため、詳細な説明は省略します。 TodoRepositoryインターフェースに追加 TodoRepositoryインターフェースに、IDを採番するnextIdメソッドと、ToDoを登録するためのaddメソッドを追加します。 package com.example.todo.application; import com.example.todo.domain.Todo; import com.example.todo.domain.TodoId; import com.example.todo.domain.UserId; import java.util.List; public interface TodoRepository { List list(UserId userId); TodoId nextId(); void add(Todo todo); } TodoServiceクラスに追加 ToDoを新しく登録するためのaddTodoメソッドを実装します。 package com.example.todo.application; import com.example.todo.domain.*; import nablarch.core.repository.di.config.externalize.annotation.SystemRepositoryComponent; import java.util.List; @SystemRepositoryComponent public class TodoService { private final TodoRepository todoRepository; public TodoService(TodoRepository todoRepository) { this.todoRepository = todoRepository; } public List list(UserId userId) { List todos = todoRepository.list(userId); return todos; } public Todo addTodo(UserId userId, TodoText text) { TodoId todoId = todoRepository.nextId(); Todo newTodo = new Todo(todoId, text, TodoStatus.INCOMPLETE, userId); todoRepository.add(newTodo); return newTodo; } } ここでは、新しくToDoのIDを採番し、新しく登録するToDoオブジェクトを生成します。生成したToDoオブジェクトは、TodoRepositoryに渡して追加するようにします。戻り値として生成したToDoオブジェクトを返すようにします。 TodoIdSequenceクラスの作成 db/migration/V1__create_table.sqlファイルには、ToDoのIDを採番するためのtodo_idというシーケンスオブジェクトを定義しています。このシーケンスオブジェクトに対応するEntityクラスを作成します。前回と同じく、主キーを使用した処理ではないため、SQLファイルを作成します。 前回Entityクラスを配置したcom.example.todo.infrastructure.entityパッケージに、TodoIdSequenceクラスを作成します。 package com.example.todo.infrastructure.entity; public class TodoIdSequence { private Long todoId; public Long getTodoId() { return todoId; } public void setTodoId(Long todoId) { this.todoId = todoId; } } TodoIdSequence.sqlファイルの作成 前回と同じように、作成したEntityクラスと同じ場所にSQLファイルを作成して、シーケンスオブジェクトから値を取得するSQLを定義します。 src/main/resources/com/example/todo/infrastructure/entity/TodoIdSequence.sql NEXT_TODO_ID = select nextval('todo_id') AS todo_id; JdbcTodoRepositoryクラスに追加 先ほどTodoRepositoryインターフェースにnextIdメソッドとaddメソッドを追加したため、実装クラスにも処理を実装します。 package com.example.todo.infrastructure; import com.example.todo.application.TodoRepository; import com.example.todo.domain.*; import com.example.todo.infrastructure.entity.TodoEntity; import com.example.todo.infrastructure.entity.TodoIdSequence; import nablarch.common.dao.EntityList; import nablarch.common.dao.UniversalDao; import nablarch.core.repository.di.config.externalize.annotation.SystemRepositoryComponent; import java.util.List; import java.util.Map; import java.util.stream.Collectors; @SystemRepositoryComponent public class JdbcTodoRepository implements TodoRepository { @Override public List list(UserId userId) { Map condition = Map.of(\"userId\", userId.value()); EntityList todoEntities = UniversalDao.findAllBySqlFile(TodoEntity.class, \"FIND_BY_USERID\", condition); return todoEntities.stream().map(this::createTodo).collect(Collectors.toList()); } @Override public TodoId nextId() { TodoIdSequence todoIdSequence = UniversalDao.findBySqlFile(TodoIdSequence.class, \"NEXT_TODO_ID\", new Object[0]); return new TodoId(todoIdSequence.getTodoId()); } @Override public void add(Todo todo) { TodoEntity todoEntity = new TodoEntity(); todoEntity.setTodoId(todo.id().value()); todoEntity.setText(todo.text().value()); todoEntity.setCompleted(todo.status() == TodoStatus.COMPLETED); todoEntity.setUserId(todo.userId().value()); UniversalDao.insert(todoEntity); } private Todo createTodo(TodoEntity entity) { return new Todo( new TodoId(entity.getTodoId()), new TodoText(entity.getText()), entity.getCompleted() ? TodoStatus.COMPLETED : TodoStatus.INCOMPLETE, new UserId(entity.getUserId())); } } nextIdメソッドでは、先ほど作成したシーケンスオブジェクトを使用し、ToDoIDを生成するように実装します。 addメソッドでは、渡されたユーザーIDとToDoオブジェクトを、DB上に追加するように実装します。 REST APIの作成 TodosActionクラスへ追加 前回作成したTodosActionクラスへ、ToDoを登録するためのREST APIを実装します。 ここでは、リクエストボディで送信された入力に異常がないか、NablarchのBean Validation機能を使用した入力値バリデーションを実装します。（参考：Nablarch - BeanValidation） NablarchのBean Validation機能は、JavaEEのBean Validation(JSR349)に準拠しており、ここではjavax.validation.constraintsパッケージ（Javadoc）にあるアノテーションを使用して、入力項目の制約を定義していきます。 @POST @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public TodoResponse post(PostRequest requestBody) { ValidatorUtil.validate(requestBody); UserId userId = new UserId(\"1001\"); TodoText text = new TodoText(requestBody.text); Todo todo = todoService.addTodo(userId, text); return new TodoResponse(todo.id(), todo.text(), todo.status()); } public static class PostRequest { @NotNull public String text; } アクションクラスのメソッドの引数にオブジェクトを設定することで、NablarchがリクエストボディのJSON文字列をオブジェクトに変換してくれ、それを受け取ることができます。入力値をチェックするため、オブジェクトを受け取った後はValidatorUtilを使用してBeanValidationを実行します。（参考：Nablarch - 登録を行う） ここでは、リクエストのJSONにtextが含まれているかを検証するため、PostRequestのtextフィールドに@NotNullアノテーションを付与します。 リクエストにtextが含まれていなければPostRequestのtextフィールドがnullになるため、BeanValidationでこの制約に引っ掛かり、例外が送出されます。例外についてはNablarchでハンドリングしてくれるため、ここではハンドリングしません。 なお、実際には項目有無以外にも様々なバリデーションが必要になりますが、ここではそれらは省略します。 入力値に異常がなかった場合、以下の処理フローで実装します。 前回と同じく、ユーザーIDはダミー値で生成する リクエストボディのToDo内容をオブジェクトとして生成する TodoServiceのToDo登録メソッドを呼び出し、ToDoを登録する 登録結果のToDoを、レスポンス用のオブジェクトに変換する REST APIのテスト 登録に成功するテストを作成 テスト用Javaディレクトリのcom.example.todo.apiパッケージに、TodoRegisterRestApiTestクラスを作成します。 package com.example.todo.api; import com.example.openapi.OpenApiValidator; import com.example.system.nablarch.FlywayExecutor; import nablarch.core.repository.SystemRepository; import nablarch.fw.web.HttpResponse; import nablarch.fw.web.RestMockHttpRequest; import nablarch.test.core.http.SimpleRestTestSupport; import org.hamcrest.Matchers; import org.junit.BeforeClass; import org.junit.Test; import javax.ws.rs.core.MediaType; import java.nio.file.Paths; import java.util.Map; import static com.jayway.jsonpath.matchers.JsonPathMatchers.hasJsonPath; import static org.hamcrest.MatcherAssert.assertThat; import static org.hamcrest.Matchers.equalTo; public class TodoRegisterRestApiTest extends SimpleRestTestSupport { public static OpenApiValidator openApiValidator = new OpenApiValidator(Paths.get(\"rest-api-specification/openapi.yaml\")); @BeforeClass public static void setUpClass() { FlywayExecutor flywayExecutor = SystemRepository.get(\"dbMigration\"); flywayExecutor.migrate(true); } @Test public void RESTAPIでToDoを登録できる() throws Exception { RestMockHttpRequest request = post(\"/api/todos\") .setHeader(\"Content-Type\", MediaType.APPLICATION_JSON) .setBody(Map.of(\"text\", \"テストする\")); HttpResponse response = sendRequest(request); assertStatusCode(\"ToDoの登録\", HttpResponse.Status.OK, response); assertThat(response.getBodyString(), hasJsonPath(\"$.id\", Matchers.notNullValue())); assertThat(response.getBodyString(), hasJsonPath(\"$.text\", equalTo(\"テストする\"))); assertThat(response.getBodyString(), hasJsonPath(\"$.completed\", equalTo(false))); openApiValidator.validate(\"postTodo\", request, response); } } 実装要領は前回と同じですが、今回はHTTPメソッドがGETではなくPOSTであるため、postメソッドを使用してリクエストオブジェクトを生成します。 idの正確な値で検証するのは難しいため、ここでは何かしら入っていることを検証するため、nullでないこととします。 続いて、テストを実行する前準備として、PostgreSQLを起動しておきます。PostgreSQLのコンテナを起動していない場合は、backendディレクトリで次のコマンドを実行します。 $ docker-compose -f docker/docker-compose.dev.yml up -d 続いて、次のコマンドでコンテナが起動していることを確認します。 $ docker-compose -f docker/docker-compose.dev.yml ps Name Command State Ports ---------------------------------------------------------------------------------- docker_postgres_1 docker-entrypoint.sh postgres Up 0.0.0.0:5432->5432/tcp PostgreSQLが起動していることを確認できたら、Mavenでテストを実行します。 mvn test 特にエラーが発生せず、テストが成功することを確認します。 Bean Validationでエラーになるテストを作成 続いて、ValidatorUtilを使用したBean Validationが実行されていることを確認するため、リクエストにtext項目を含めずに送信するテストを TodoRegisterRestApiTest クラスに追加します。 @Test public void ToDo登録時にtext項目が無い場合_登録に失敗して400になる() { RestMockHttpRequest request = post(\"/api/todos\") .setHeader(\"Content-Type\", MediaType.APPLICATION_JSON) .setBody(Collections.emptyMap()); HttpResponse response = sendRequest(request); assertStatusCode(\"ToDoの登録\", HttpResponse.Status.BAD_REQUEST, response); } Nablarchは、ValidatorUtilで送出された例外をハンドリングし、レスポンスのステータスコードを400 Bad Requestに設定します。そのため、レスポンスのステータスコードを検証します。 PostgreSQLは先ほどのテスト実行時に起動しているため、Mavenでテストを実行します。 mvn test 特にエラーが発生せず、テストが成功することを確認します。 これで、ToDo登録のREST APIの実装は完了です。 "},"todo/backend/todo-update/":{"url":"todo/backend/todo-update/","title":"ToDo状態更新のREST API","keywords":"","body":"ToDo状態更新のREST API ToDoの状態を更新するために使用するREST APIを実装します。 ToDoを更新する処理の実装 まず、ToDoの状態を更新する処理を実装します。ここはREST APIと直接関係が無い部分であるため、詳細な説明は省略します。 Todoクラスに追加 ToDoの状態を変更したインスタンスを生成するchangeStatusメソッドを追加します。 public Todo changeStatus(TodoStatus status) { return new Todo(id, text, status, userId); } TodoRepositoryインターフェースに追加 TodoRepositoryインターフェースに、ToDoを取得するためのgetメソッド、ToDoを更新するためのupdateメソッドを追加します。 Todo get(TodoId todoId); void update(Todo todo); TodoServiceクラスに追加 ToDoの状態を更新するためのupdateStatusメソッドを実装します。 public Todo updateStatus(TodoId todoId, TodoStatus status) { Todo todo = todoRepository.get(todoId); Todo changedTodo = todo.changeStatus(status); todoRepository.update(changedTodo); return changedTodo; } JdbcTodoRepositoryクラスに追加 先ほどTodoRepositoryインターフェースにgetメソッドとupdateメソッドを追加したため、実装クラスにも処理を実装します。 @Override public Todo get(TodoId todoId) { TodoEntity todoEntity = UniversalDao.findById(TodoEntity.class, todoId.value()); return createTodo(todoEntity); } @Override public void update(Todo todo) { TodoEntity todoEntity = new TodoEntity(); todoEntity.setTodoId(todo.id().value()); todoEntity.setText(todo.text().value()); todoEntity.setCompleted(todo.status() == TodoStatus.COMPLETED); todoEntity.setUserId(todo.userId().value()); UniversalDao.update(todoEntity); } getメソッドでは、ToDoのIDからDBに登録されているToDoを取得します。ToDoのIDは主キーであるため、SQLファイルは書かずにUniversalDao#findByIdを使用して検索することができます。（参考：Nablarch SQLを書かなくても単純なCRUDができる） updateメソッドでは、引数のToDoからDBを更新しています。 REST APIの作成 TodoActionクラスの作成 今回は、単一のToDoを表現したパスに変わるため、新しくTodoActionクラスを作成します。（同じアクションクラスでも実装可能ですが、ここでは分けます） package com.example.todo.api; import com.example.todo.application.TodoService; import com.example.todo.domain.*; import nablarch.core.repository.di.config.externalize.annotation.SystemRepositoryComponent; import nablarch.core.validation.ee.ValidatorUtil; import nablarch.fw.ExecutionContext; import nablarch.fw.web.HttpRequest; import javax.validation.constraints.NotNull; import javax.ws.rs.*; import javax.ws.rs.core.MediaType; @SystemRepositoryComponent @Path(\"/todos/{todoId}\") public class TodoAction { private final TodoService todoService; public TodoAction(TodoService todoService) { this.todoService = todoService; } @PUT @Consumes(MediaType.APPLICATION_JSON) @Produces(MediaType.APPLICATION_JSON) public TodoResponse put(HttpRequest request, ExecutionContext context, PutRequest requestBody) { ValidatorUtil.validate(requestBody); TodoId todoId = new TodoId(Long.valueOf(request.getParam(\"todoId\")[0])); TodoStatus status = requestBody.completed ? TodoStatus.COMPLETED : TodoStatus.INCOMPLETE; Todo todo = todoService.updateStatus(todoId, status); return new TodoResponse(todo.id(), todo.text(), todo.status()); } public static class PutRequest { @NotNull public Boolean completed; } public static class TodoResponse { public final Long id; public final String text; public final Boolean completed; public TodoResponse(TodoId id, TodoText text, TodoStatus status) { this.id = id.value(); this.text = text.value(); this.completed = status == TodoStatus.COMPLETED; } } } putメソッドは以下の処理を実装します。 登録と同じように、ValidatorUtilを使用してBean Validationを実行 ToDoのIDをパスパラメータから取得 ToDo状態のオブジェクトを生成 TodoServiceの状態更新メソッドを呼び出し 更新結果をレスポンスのオブジェクトに変換 REST APIのテスト テスト用Javaディレクトリのcom.example.todo.apiパッケージに、TodoUpdateRestApiTestクラスを作成します。 package com.example.todo.api; import com.example.openapi.OpenApiValidator; import com.example.system.nablarch.FlywayExecutor; import nablarch.core.repository.SystemRepository; import nablarch.fw.web.HttpResponse; import nablarch.fw.web.RestMockHttpRequest; import nablarch.test.core.http.SimpleRestTestSupport; import org.junit.BeforeClass; import org.junit.Test; import javax.ws.rs.core.MediaType; import java.nio.file.Paths; import java.util.Map; import static com.jayway.jsonpath.matchers.JsonPathMatchers.hasJsonPath; import static org.hamcrest.MatcherAssert.assertThat; import static org.hamcrest.Matchers.equalTo; public class TodoUpdateRestApiTest extends SimpleRestTestSupport { public static OpenApiValidator openApiValidator = new OpenApiValidator(Paths.get(\"rest-api-specification/openapi.yaml\")); @BeforeClass public static void setUpClass() { FlywayExecutor flywayExecutor = SystemRepository.get(\"dbMigration\"); flywayExecutor.migrate(true); } @Test public void RESTAPIでToDoの状態を更新できる() throws Exception { RestMockHttpRequest request = put(\"/api/todos/2002\") .setHeader(\"Content-Type\", MediaType.APPLICATION_JSON) .setBody(Map.of(\"completed\", true)); HttpResponse response = sendRequest(request); assertStatusCode(\"ToDoのステータス更新\", HttpResponse.Status.OK, response); assertThat(response.getBodyString(), hasJsonPath(\"$.id\", equalTo(2002))); assertThat(response.getBodyString(), hasJsonPath(\"$.text\", equalTo(\"やること２\"))); assertThat(response.getBodyString(), hasJsonPath(\"$.completed\", equalTo(true))); openApiValidator.validate(\"putTodo\", request, response); } } 実装要領は登録と同じです。 続いて、テストを実行する前準備として、PostgreSQLを起動しておきます。PostgreSQLのコンテナを起動していない場合は、backendディレクトリで次のコマンドを実行します。 $ docker-compose -f docker/docker-compose.dev.yml up -d 続いて、次のコマンドでコンテナが起動していることを確認します。 mvn test 特にエラーが発生せず、テストが成功することを確認します。 これで、ToDo状態更新のREST APIの実装は完了です。 "},"todo/backend/cors/":{"url":"todo/backend/cors/","title":"CORSの設定","keywords":"","body":"CORSの設定 フロントエンドアプリでCORSを使用するための設定をしましたが、同様に、バックエンドアプリでもCORSを使用するための設定をする必要があります。 Nablarchには、リクエストやレスポンスに対して横断的な処理を行うための仕組みがあり、処理を実装したものを「ハンドラ」と呼びます。（アーキテクチャ | Nablarch） ハンドラは自身で実装することもできますが、Nablarchでは様々なハンドラが予め用意されています。CORSを使用するためのハンドラもNablarchから提供されているため、ここではそれを使用します。なお、example-chatのバックエンドでも同様の実装をしています。 ハンドラはコンポーネントとして定義する必要があるため、rest-component-configurationファイルに次のコンポーネント定義を追加します。 ... ... ... 続いて、コンポーネント定義で使用する環境依存値を設定します。env.configに、以下の値を追加します。 # CORSで許可するオリジン cors.origins=http://localhost:3000 これで、バックエンドのCORS設定については完了です。 "},"todo-delete/":{"url":"todo-delete/","title":"ToDoを削除する（演習）","keywords":"","body":"ToDoを削除する（演習） ToDoページで、ToDoを削除できるように実装します。 今までの実装とほぼ同じ要領で実装ができるため、演習として自身で実装してみましょう。 機能説明 ToDoページで一覧表示しているToDoの右側にあるxボタンをクリックすると、対象のToDoを一覧から削除します。 実装のヒント OpenAPI 削除に使用するREST APIはDELETE /api/todos/{id}です フロントエンド チェックボックスでToDoの状態を更新する実装を参考にしてください バックエンド ToDo状態更新のREST APIの実装を参考にしてください。 主キーによるDELETEをする場合は、ユニバーサルDAOのCRUD機能が利用できます。（参考） Nablarch(5u18)での注意点 バックエンドで使用しているNablarchのバージョンは5u18ですが、このバージョンではCORSのプリフライトリクエストにAccess-Control-Request-Headersヘッダが必須になります。 ただし、この時点でToDoの削除機能を実装して動作させた場合、許可が必要なヘッダ項目が無いためにAccess-Control-Request-Headersヘッダも無い状態となっています。 そのため、ToDoの削除機能を動作させるにはCORSの設定クラスを差し替える必要があります。 com.example.system.nablarchパッケージに、次のCustomCorsクラスを作成します。 package com.example.system.nablarch; import nablarch.fw.ExecutionContext; import nablarch.fw.jaxrs.cors.BasicCors; import nablarch.fw.web.HttpRequest; public class CustomCors extends BasicCors { @Override public boolean isPreflightRequest(HttpRequest request, ExecutionContext context) { return request.getMethod().equals(\"OPTIONS\") && request.getHeader(Headers.ORIGIN) != null && request.getHeader(Headers.ACCESS_CONTROL_REQUEST_METHOD) != null; } private static final class Headers { static final String ORIGIN = \"Origin\"; static final String ACCESS_CONTROL_REQUEST_METHOD = \"Access-Control-Request-Method\"; } } Nablarchが提供しているBasicCorsクラスを継承し、isPreflightRequest(HttpRequest, ExecutionContext)メソッドをオーバーライドしてプリフライトリクエストの判定を変更しています。 次に、rest-component-configuration.xmlファイルで定義しているCORS設定クラスを、BasicCorsからCustomCorsに修正します。 以上の対応で、Access-Control-Request-Headersヘッダが無いプリフライトリクエストでも動作可能になります。 "},"auth/":{"url":"auth/","title":"ユーザー認証の実装","keywords":"","body":"ユーザー認証の実装 ToDoページが完成しましたので、次にユーザー認証を実装していきます。 ユーザー認証を実装することで、アカウント登録やログイン、ログアウトをできるようにします。 目次 フロントエンド ユーザー認証のフロントエンドを実装します。 バックエンド ユーザー認証のバックエンドを実装します。 動作確認 フロントエンドとバックエンドを接続して動作を確認します。 "},"auth/frontend/":{"url":"auth/frontend/","title":"フロントエンド","keywords":"","body":"フロントエンド ユーザー認証のフロントエンドを、次の順で実装していきます。 目次 ページ外観の作成 ユーザー認証で追加するページの外観を作成します。 ルーティングの設定 React Routerを使用して、URLによるルーティングができるように設定します。 ユーザーコンテクストの作成 Reactのコンテクストを使用して、ユーザー認証で使用するユーザーコンテクストを作成します。 ナビゲーションメニューの切替 ユーザーコンテクストを使用して、ナビゲーションメニューが切り替わるように実装します。 サインアップ ユーザーコンテクストを使用して、サインアップ処理を実装します。 ログイン ユーザーコンテクストを使用して、ログイン処理を実装します。 ログアウト ユーザーコンテクストを使用して、ログアウト処理を実装します。 "},"auth/frontend/page/":{"url":"auth/frontend/page/","title":"ページ外観の作成","keywords":"","body":"ページ外観の作成 ユーザー認証で追加するページの外観を作成します。 コンポーネントの分割 それぞれのページにあるナビゲーションメニューのヘッダについては、表示されているメニューは違いますがToDoページとほぼ同じものであるため、ToDoページで作成したNavigationHeaderコンポーネントを使用します。 ヘッダ以外の部分については、それぞれのページ内では用途が同じ情報のみ扱っているため、それぞれのページ全体をコンポーネントとします。 NavigationHeader：ナビゲーションメニューのヘッダ Welcome：トップページのウェルカムメッセージを表示する Signup：サインアップフォームを表示する Login：ログインフォームを表示する これらのコンポーネントを、ToDoページのコンポーネントと並べて次の階層構造となるように作成していきます。 NavigationHeader（作成済み） Welcome Signup Login TodoBoard（作成済み） TodoForm TodoFilter TodoList TodoItem コンポーネントの作成 Todoページを作成した時と同じように、spa-restapi-handson/design-mockに配置されているデザインモックを元に、それぞれのコンポーネントを作成していきます。 Welcomeコンポーネント まず、Welcomeコンポーネントを作成します。 src/components/Welcome.tsx import React from 'react'; import './Welcome.css'; export const Welcome: React.FC = () => { return ( Welcome 登録する ); }; src/components/Welcome.css .Welcome_content { height: 90vh; display: flex; justify-content: center; align-items: center; overflow: auto; } .Welcome_title { font-size: 60px; } .Welcome_buttonGroup { text-align: center; } .Welcome_button { width: 175px; cursor: pointer; line-height: 1; border: none; font-size: 1rem; color: white; background-color: darkgreen; border-radius: 5px; padding: 15px 30px; } .Welcome_button:hover { background-color: green; } Signupコンポーネント 続いて、Signupコンポーネントを作成します。 src/components/Signup.tsx import React from 'react'; import './Signup.css'; export const Signup: React.FC = () => { return ( ユーザー登録 名前 パスワード 登録する ); }; src/components/Signup.css .Signup_content { height: 90vh; display: flex; justify-content: center; align-items: center; overflow: auto; text-align: center; } .Signup_box { width: 50%; } .Signup_title { height: 70px; } .Signup_title h1 { margin: 10px 0; } .Signup_form { width: 50%; padding: 0 25%; } .Signup_item { margin: 20px 0; height: 75px; } .Signup_item input { width: 100%; border-radius: 5px; padding: 8px; border: solid 1px lightgray; background-color: #fafbfc; font-size: 16px; margin-top: 10px; outline: none; } .Signup_item input:focus { background-color: white; } .Signup_label { text-align: left; } .Signup_buttonGroup { text-align: center; margin-top: 40px; } .Signup_button { width: 175px; cursor: pointer; line-height: 1; border: none; font-size: 1rem; color: white; background-color: darkgreen; border-radius: 5px; padding: 15px 30px; } .Signup_button:hover { background-color: green; } Loginコンポーネント 続いて、Loginコンポーネントを作成します。 src/components/Login.tsx import React from 'react'; import './Login.css'; export const Login: React.FC = () => { return ( ログイン 名前 パスワード ログインする ); }; src/components/Login.css .Login_content { height: 90vh; display: flex; justify-content: center; align-items: center; overflow: auto; text-align: center; } .Login_box { width: 50%; } .Login_title { height: 70px; } .Login_title h1 { margin: 10px 0; } .Login_form { width: 50%; padding: 0 25%; } .Login_item { margin: 20px 0; height: 75px; } .Login_item input { width: 100%; border-radius: 5px; padding: 8px; border: solid 1px lightgray; background-color: #fafbfc; font-size: 16px; margin-top: 10px; outline: none; } .Login_item input:focus { background-color: white; } .Login_label { text-align: left; } .Login_buttonGruop { text-align: center; margin-top: 40px; } .Login_button { width: 175px; cursor: pointer; line-height: 1; border: none; font-size: 1rem; color: white; background-color: darkgreen; border-radius: 5px; padding: 15px 30px; } .Login_button:hover { background-color: green; } 動作確認 ページを表示して確認したいところですが、複数のページをそれぞれ確認しづらいため、次に実装するURLルーティングが終わってから確認することにします。 "},"auth/frontend/context/":{"url":"auth/frontend/context/","title":"ユーザーコンテクストの作成","keywords":"","body":"ユーザーコンテクストの作成 ユーザー情報のような特定のコンポーネントに依存しない値は、様々なコンポーネントで使用する可能性がありますが、その場合にはプロパティを使用してコンポーネントの階層に渡していく必要が出てきます。 このような情報を扱う場合、コンテクストと呼ばれるReactの機能を利用することで、プロパティを使用せずにコンポーネント間で値を共有することが出来ます。（参考：コンテクストで深くデータを受け渡す | React） ここでは、ユーザーの認証に関する値を持つコンテクスト（以下ユーザーコンテクスト）を作成し、認証に関わるコンポーネントではそのコンテクストを使用できるように実装していきます。ここでは、認証に関する情報を集約させるため、ユーザーコンテクストには次の値を持たせます。 サインアップするための関数 ログインするための関数 ログアウトするための関数 ユーザー名 ログインしているかどうか なお、example-chatのバックエンド実装でも同様の実装をしています。 ユーザーコンテクストの定義 まず、ユーザーコンテクストを作成します。 コンテクストに関する実装を配置するため、src/contextsディレクトリを作成し、その中にUserContext.tsxを作成します。（後ほどJSXを使用する実装を入れるため、拡張子にはtsxを使用しておきます） src/contexts/UserContext.tsx import React from 'react'; export class AccountConflictError {} export class AuthenticationFailedError {} type Props = { children?: React.ReactNode, } type ContextValueType = { signup: (userName: string, password: string) => Promise, login: (userName: string, password: string) => Promise, logout: () => Promise, userName: string isLoggedIn: boolean, } export const UserContext = React.createContext({} as ContextValueType); React v18からpropsを定義する際にchildrenプロパティを明示的に列挙する必要があるので、Props型を定義します。 React.createContextを使用して、コンテクストを作成します。ユーザーコンテクストを扱う際に型を使用したいため、ContextValueType型も定義します。 また、サインアップやログインのREST APIの仕様として、入力ミス等で失敗した場合にはエラーレスポンスが返却されます。生成したクライアントコードでは、エラーレスポンスであった場合は例外として送出されます。ここでは、ユーザーコンテクストの利用者がエラーを扱いやすくするため、エラーを表現するオブジェクトに変換して返すようにします。 ユーザーコンテクストを取得するフックの作成 関数コンポーネントでコンテクストを使用するためのフックとしてuseContextが提供されています。useContextを使用することで、関数コンポーネントでコンテクストとして設定されている値（コンテクストオブジェクト）を取得することができます。（参考：useContext | React） 各コンポーネントでuseContextを使用してもよいですが、ここではユーザーコンテクストを明示的に取得するためのフックを作成します。ユーザーコンテクストに関わる実装はUserContext.tsxに集約するため、UserContext.tsxに次のような実装を追加します。 import React, { useContext } from 'react'; ... export const useUserContext = () => useContext(UserContext); コンテクストプロバイダの作成 ユーザーコンテクストを各コンポーネントで使用できるようにするためには、プロパイダと呼ばれるコンポーネントを使用します。（参考：SomeContext.Provider | React） プロパイダコンポーネントのvalue属性に渡した値が、子要素のコンポーネントで使用できるようになります。ここでは、このプロパイダコンポーネントとそれに渡す値を、独立したコンポーネントとして使用できるようにするため、UserContextProviderコンポーネントを作成します。ユーザーコンテクストに関わる実装はUserContext.tsxにまとめます。 import React, { useContext, useState } from 'react'; import { BackendService } from '../backend/BackendService'; ... export const UserContextProvider: React.FC = ({ children }) => { const [userName, setUserName] = useState(''); const contextValue: ContextValueType = { signup: async (userName, password) => { try { await BackendService.signup(userName, password); } catch(error: any) { if (error.status === 409) { return new AccountConflictError(); } throw error; } }, login: async (userName, password) => { try { await BackendService.login(userName, password); setUserName(userName); } catch(error: any) { if (error.status === 401) { return new AuthenticationFailedError(); } throw error; } }, logout: async () => { await BackendService.logout(); setUserName(''); }, userName: userName, isLoggedIn: userName !== '' }; return ( {children} ); }; コンテクストプロパイダの配置 ユーザーコンテクストはどのコンポーネントからでも使用できるようにするため、UserContextProviderコンポーネントをAppコンポーネントに配置します。 import { UserContextProvider } from './contexts/UserContext'; ... function App() { return ( ); } 動作確認 コンテクストを使用しているコンポーネントが無ければ確認しづらいため、最後にまとめて確認します。 "},"auth/frontend/header/":{"url":"auth/frontend/header/","title":"ナビゲーションメニューの切替","keywords":"","body":"ナビゲーションメニューの切替 ユーザーコンテクストを使用して、ナビゲーションメニューが切り替わるように実装します。 ナビゲーションメニュー切替処理を実装 NavigationHeaderコンポーネントにナビゲーションメニューの切替処理を実装します。 import React from 'react'; import './NavigationHeader.css'; import { Link } from 'react-router-dom'; import { useUserContext } from '../contexts/UserContext'; export const NavigationHeader: React.FC = () => { const userContext = useUserContext(); const logout = async () => { window.location.href = '/'; }; return ( Todoアプリ { userContext.isLoggedIn ? ( {userContext.userName}さん ログアウト ) : ( ログイン )} ); }; ユーザーコンテクストは先ほど作成したuseUserContextで取得します。ユーザーコンテクストからログイン済みであるかを取得し、それによりメニューを切り替えます。 動作確認 単体での動作確認がしづらいため、最後にまてめて動作を確認します。 "},"auth/frontend/signup/":{"url":"auth/frontend/signup/","title":"サインアップ","keywords":"","body":"サインアップ ユーザーコンテクストを使用して、サインアップ処理を実装します。 サインアップ処理の実装 Signupコンポーネントにサインアップ処理を実装します。 import React from 'react'; import { useHistory } from 'react-router-dom'; import './Signup.css'; import { useInput } from '../hooks/useInput'; import { useUserContext } from '../contexts/UserContext'; export const Signup: React.FC = () => { const history = useHistory(); const [userName, userNameAttributes] = useInput(''); const [password, passwordAttributes] = useInput(''); const userContext = useUserContext(); const signup: React.FormEventHandler = async (event) => { event.preventDefault(); await userContext.signup(userName, password); history.push('/'); }; return ( ユーザー登録 名前 パスワード 登録する ); }; フォームには名前とパスワードのテキストボックスがあるため、ToDo登録と同様にuseInputを使用してstateとプロパティ用オブジェクトを作成し、フォームのJSXで各項目のプロパティとして展開します。 フォームのサブミット時には、ユーザーコンテクストのサインアップ関数に入力値を渡して実行するようにします。 入力値のバリデーション ToDoを登録する際には入力値のバリデーションを行いませんでしたが、ここでは入力値に対して次のバリデーションを実装します。 名前が入力されているか パスワードが入力されているか パスワードが4文字以上であるか example-chatのバックエンドでもこのような入力値のバリデーションを実装していますので、その実装を流用します。 example-chatのsrc/framework/validationディレクトリに、入力値のバリデーションを実装したファイルが格納されているため、このディレクトリを、src/validationとしてコピーします。 この中にバリデーション用のフックであるuseValidationが実装されているため、これを使用してSignupコンポーネントでバリデーションを実装します。 ... import { stringField, useValidation } from '../validation'; type ValidationFields = { userName: string password: string }; export const Signup: React.FC = () => { ... const { error, handleSubmit } = useValidation({ userName: stringField() .required('名前を入力してください'), password: stringField() .required('パスワードを入力してください') .minLength(4, 'パスワードは4桁以上入力してください'), }); ... return ( ユーザー登録 名前 {error.userName} パスワード {error.password} 登録する ); ここではエラーメッセージのスタイル用に、クラス名としてerrorを使用します。これは他のコンポーネントでも使用するため、App.cssに次のスタイル定義を追加します。 src/App.css .error { color: red; } useValidationでは、型引数により各項目で使用できるバリデーションを切り替えます。そのため、まずはバリデーション対象になる項目を定義したValidationFields型を定義します。 useValidationの型引数にValidationFieldsを指定し、引数にバリデーションを定義したオブジェクトを生成して渡します。プロパティのキーはValidationFieldsに対応し、各項目でどのようなバリデーションを行うかを定義します。 string型の項目を検証するためのstringFieldsが用意されているので、これを起点にバリデーションを指定していきます。stringFieldsでは、必須入力をチェックするためのrequiredや、最小文字数をチェックするためのminLength等が用意されており、ここでのバリデーションはそれらを使用します。 useValidationの戻り値として、バリデーションエラーが格納されるerrorと、サブミット時に自動で実行するためのhandleSubmitを受け取ります。 errorは実際にはuseStateによるstateであり、バリデーションでエラーになるとこのstateにメッセージが設定されます。errorのプロパティはuseValidationのプロパティに一対一で対応しています。例えば、userNameに対するバリデーションでエラーとなった場合、error.userNameにエラーメッセージが設定されます。 ここでは、各テキストボックスの下にエラーメッセージを表示するように、JSXでinputの直後にdivでエラーメッセージを表示するようにします。 handleSubmitは関数であり、第1引数に入力値と、第2引数にエラーが発生しなかった場合のコールバック関数を渡します。 サインアップ失敗時のハンドリング サインアップのREST APIでは、登録する名前と同じ名前がすでにが登録されていたら、ステータスコードが409であるエラーレスポンスが返却されます。 ユーザーコンテクストのサインアップ関数を実装した際、そのエラーレスポンスであればAccountConflictErrorオブジェクトを返却するように実装しましたので、ここでは、サインアップ関数の実行結果からエラーであるかを判断し、エラーであればフォームの上にエラーメッセージを表示するようにします。 useValidationではこのようなサーバーサイドのエラーについてはハンドリングできないため、エラーメッセージを表すstateを新しく作成するため、次のように実装します。 import React, { useState } from 'react'; ... import { AccountConflictError, useUserContext } from '../contexts/UserContext'; ... export const Signup: React.FC = () => { ... const [formError, setFormError] = useState(''); ... const signup: React.FormEventHandler = async (event) => { event.preventDefault(); const result = await userContext.signup(userName, password); if (result instanceof AccountConflictError) { setFormError('サインアップに失敗しました。同じ名前が登録されています。'); return; } history.push('/'); }; return ( ユーザー登録 {formError} setFormError(''))}> ... サインアップ関数の戻り値がAccountConflictErrorのオブジェクトであれば、サインアップ失敗としてエラーメッセージをstateに設定します。フォームの上にエラーメッセージを表示するように、JSXでformの直前にdivでエラーメッセージを表示するようにします。 なお、フォーム上のエラーメッセージが表示された状態で再度フォームに入力し、入力値のバリデーションでエラーとなった場合には、フォーム上のエラーメッセージは表示されないようにしたいです。 handleSubmitの第3引数には、バリデーションを実行する前に呼び出されるコールバック関数を渡すことができるため、ここではエラーメッセージを初期化する関数を渡すようにします。 これで、サインアップ失敗時のハンドリングの実装は完了です。 動作確認 単体での動作確認がしづらいため、最後にまとめて動作を確認します。 "},"auth/frontend/login/":{"url":"auth/frontend/login/","title":"ログイン","keywords":"","body":"ログイン ユーザーコンテクストを使用して、ログイン処理を実装します。 ログイン処理の実装 Loginコンポーネントにログイン処理を実装します。また、入力値のバリデーション、ユーザー認証が失敗した場合のエラーメッセージの表示についても、Signupコンポーネントと同様に実装します。 import React, { useState } from 'react'; import { useHistory } from 'react-router-dom'; import './Login.css'; import { useInput } from '../hooks/useInput'; import { AuthenticationFailedError, useUserContext } from '../contexts/UserContext'; import { stringField, useValidation } from '../validation'; type ValidationFields = { userName: string password: string }; export const Login: React.FC = () => { const history = useHistory(); const [userName, userNameAttributes] = useInput(''); const [password, passwordAttributes] = useInput(''); const [formError, setFormError] = useState(''); const userContext = useUserContext(); const { error, handleSubmit } = useValidation({ userName: stringField() .required('名前を入力してください'), password: stringField() .required('パスワードを入力してください') }); const login: React.FormEventHandler = async (event) => { event.preventDefault(); const result = await userContext.login(userName, password); if (result instanceof AuthenticationFailedError) { setFormError('ログインに失敗しました。名前またはパスワードが正しくありません。') return; } history.push('/board'); }; return ( ログイン {formError} setFormError(''))}> 名前 {error.userName} パスワード {error.password} ログインする ); }; フォームのサブミット時に、ユーザーコンテクストのログイン関数を実行するようにします。 動作確認 単体での動作確認がしづらいため、最後にまてめて動作を確認します。 "},"auth/frontend/logout/":{"url":"auth/frontend/logout/","title":"ログアウト","keywords":"","body":"ログアウト ユーザーコンテクストを使用して、ログアウト処理を実装します。 ログアウト処理の実装 Loginコンポーネントと同様に、NavigationHeaderコンポーネントにログアウト処理を実装します。 export const NavigationHeader: React.FC = () => { ... const logout = async () => { await userContext.logout(); window.location.href = '/'; }; ... ログアウトボタンをクリックしたら、ユーザーコンテクストのログアウト関数を実行するようにします。 動作確認 サインアップやログイン、ログアウト処理の実装ができましたので、モックサーバとフロントエンドアプリを起動して、動作確認をしてみましょう。 モックサーバを起動していない場合は、frontendディレクトリで次のコマンドを実行します。 $ docker-compose -f docker/docker-compose.api-mock.yml up フロントエンドアプリを起動していない場合は、frontendディレクトリで次のコマンドを実行します。 npm start モックサーバとフロントエンドアプリが起動したら、ページを操作してユーザー認証の動作を確認します。 "},"auth/backend/":{"url":"auth/backend/","title":"バックエンド","keywords":"","body":"バックエンド ユーザー認証のバックエンドを、次の順で実装していきます。 目次 サインアップのREST API サインアップに使用するREST APIを実装します。 ログインのREST API ログインに使用するREST APIを実装します。 ログアウトのREST API ログアウトに使用するREST APIを実装します。 REST APIへのアクセス制限 ログイン状態によるREST APIへのアクセス制御を実装します。 ToDo管理でのユーザー取得 ToDo管理のREST APIで、ログインしたユーザーを使用するように修正します。 "},"auth/backend/signup/":{"url":"auth/backend/signup/","title":"サインアップのREST API","keywords":"","body":"サインアップのREST API サインアップに使用するREST APIを実装します。 ToDo管理の実装では、レイヤーで責務を分離したり値オブジェクト等のクラスを作成したりしていましたが、ユーザー認証の実装では、REST APIと機能実装を分離するだけにし、値オブジェクト等も使用しない実装とします。 アカウント登録処理の実装 サインアップではアカウントを登録するため、アカウントの登録処理を実装します。 Entityクラスの作成 ユニバーサルDAOを使用するため、DBのテーブルに対応するEntityクラスを作成します。 まず、Entityクラスを格納するcom.example.authentication.application.entityパッケージを作成します。 続いて、accountテーブルに対応したAccountEntityクラスを作成します。 package com.example.authentication.application.entity; import javax.persistence.*; @Entity @Table(name = \"account\") @Access(AccessType.FIELD) public class AccountEntity { @Id private String userId; private String password; public String getUserId() { return userId; } public void setUserId(String userId) { this.userId = userId; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } } 続いて、user_profileテーブルに対応したUserProfileEntityクラスを作成します。 package com.example.authentication.application.entity; import javax.persistence.*; @Entity @Table(name = \"user_profile\") @Access(AccessType.FIELD) public class UserProfileEntity { @Id private String userId; private String name; public String getUserId() { return userId; } public void setUserId(String userId) { this.userId = userId; } public String getName() { return name; } public void setName(String name) { this.name = name; } } ユーザー登録クラスの作成 まず、ユーザー登録クラスを格納するcom.example.authentication.applicationパッケージを作成します。 アカウント登録処理を実装するため、AccountRegistrationServiceクラスを作成します。 package com.example.authentication.application; import com.example.authentication.application.entity.AccountEntity; import com.example.authentication.application.entity.UserProfileEntity; import nablarch.common.dao.UniversalDao; import nablarch.core.repository.di.config.externalize.annotation.SystemRepositoryComponent; import java.util.UUID; @SystemRepositoryComponent public class AccountRegistrationService { public void register(String userName, String password) { String userId = generateUserId(); insertAccount(userId, password); insertUserProfile(userId, userName); } private String generateUserId() { return UUID.randomUUID().toString(); } private void insertAccount(String userId, String password) { AccountEntity accountEntity = new AccountEntity(); accountEntity.setUserId(userId); accountEntity.setPassword(password); UniversalDao.insert(accountEntity); } private void insertUserProfile(String userId, String userName) { UserProfileEntity userProfileEntity = new UserProfileEntity(); userProfileEntity.setUserId(userId); userProfileEntity.setName(userName); UniversalDao.insert(userProfileEntity); } } REST APIの実装 まず、アクションクラスを格納するcom.example.authentication.apiパッケージを作成します。 ユーザー認証関連のREST APIを実装するため、AuthenticationActionクラスを作成します。 package com.example.authentication.api; import com.example.authentication.application.AccountRegistrationService; import nablarch.core.repository.di.config.externalize.annotation.SystemRepositoryComponent; import nablarch.core.validation.ee.ValidatorUtil; import javax.validation.constraints.NotNull; import javax.ws.rs.Consumes; import javax.ws.rs.POST; import javax.ws.rs.Path; import javax.ws.rs.core.MediaType; @Path(\"/\") @SystemRepositoryComponent public class AuthenticationAction { private final AccountRegistrationService registrationService; public AuthenticationAction(AccountRegistrationService registrationService) { this.registrationService = registrationService; } @Path(\"/signup\") @POST @Consumes(MediaType.APPLICATION_JSON) public void signup(SignupRequest requestBody) { ValidatorUtil.validate(requestBody); registrationService.register(requestBody.userName, requestBody.password); } public static class SignupRequest { @NotNull public String userName; @NotNull public String password; } } この後に実装するログイン等のREST APIもこのクラスで実装するため、クラスには空のパスを指定した@Pathアノテーションを付与し、メソッドにサインアップ用のパスを指定した@Pathアノテーションを付与します。 ユーザー名とパスワードが送信されているかチェックし、先ほど実装したアカウント登録機能を呼び出します。 REST APIのテスト 認証に成功するテストの作成 REST APIをテストするため、AuthenticationRestApiTestクラスを作成します。 ToDo管理で作成したテストと同様に、NablarchのREST APIテスティングフレームワークと、OpenAPIドキュメントを使用します。 package com.example.authentication.api; import com.example.openapi.OpenApiValidator; import nablarch.fw.web.HttpResponse; import nablarch.fw.web.RestMockHttpRequest; import nablarch.test.core.http.SimpleRestTestSupport; import org.junit.Test; import javax.ws.rs.core.MediaType; import java.nio.file.Paths; import java.util.Map; public class AuthenticationRestApiTest extends SimpleRestTestSupport { public static OpenApiValidator openApiValidator = new OpenApiValidator(Paths.get(\"rest-api-specification/openapi.yaml\")); @Test public void RESTAPIでサインアップできる() throws Exception { RestMockHttpRequest request = post(\"/api/signup\") .setHeader(\"Content-Type\", MediaType.APPLICATION_JSON) .setBody(Map.of( \"userName\", \"signup-test\", \"password\", \"pass\")); HttpResponse response = sendRequest(request); assertStatusCode(\"サインアップ\", HttpResponse.Status.NO_CONTENT, response); openApiValidator.validate(\"signup\", request, response); } } 続いて、テストを実行する前準備として、PostgreSQLを起動しておきます。PostgreSQLのコンテナを起動していない場合は、backendディレクトリで次のコマンドを実行します。 $ docker-compose -f docker/docker-compose.dev.yml up -d 続いて、次のコマンドでコンテナが起動していることを確認します。 $ docker-compose -f docker/docker-compose.dev.yml ps Name Command State Ports ---------------------------------------------------------------------------------- docker_postgres_1 docker-entrypoint.sh postgres Up 0.0.0.0:5432->5432/tcp PostgreSQLが起動していることを確認できたら、Mavenでテストを実行します。 mvn test 特にエラーが発生せず、テストが成功することを確認します。 名前の不一致で認証に失敗するテストの作成 続けて、名前の不一致で認証に失敗する場合のテストを追加します。 @Test public void 名前が登録済みの場合_サインアップに失敗して409になる() throws Exception { RestMockHttpRequest firstRequest = post(\"/api/signup\") .setHeader(\"Content-Type\", MediaType.APPLICATION_JSON) .setBody(Map.of( \"userName\", \"signup-conflict-test\", \"password\", \"pass\")); sendRequest(firstRequest); RestMockHttpRequest secondRequest = post(\"/api/signup\") .setHeader(\"Content-Type\", MediaType.APPLICATION_JSON) .setBody(Map.of( \"userName\", \"signup-conflict-test\", \"password\", \"pass\")); HttpResponse response = sendRequest(secondRequest); assertStatusCode(\"サインアップ\", HttpResponse.Status.CONFLICT, response); openApiValidator.validate(\"signup\", secondRequest, response); } テストを実行すると、次のようにステータスコードが409 Conflictではなく204 No Contentになり失敗します。 [ERROR] 名前が登録済みの場合_サインアップに失敗して409になる Time elapsed: 0.047 s but was: at com.example.authentication.AuthenticationRestApiTest.名前が登録済みの場合_サインアップに失敗して409になる(AuthenticationRestApiTest.java:49) アカウントの登録時に同じ名前で登録されていないかチェックしていないため、アカウントの登録に成功しています。 同じ名前のレコードがあるかを検索するために、UserProfileEntityクラスに対応したUserProfileEntity.sqlファイルを作成し、SQLを作成します。 src/main/resources/com/example/authentication/application/entity/UserProfileEntity.sql FIND_BY_USERNAME = select user_id FROM user_profile WHERE name = :userName 続いて、登録結果を表現するためのAccountRegistrationResultを作成します。 package com.example.authentication.application; public enum AccountRegistrationResult { SUCCESS, NAME_CONFLICT } 続いて、AccountRegistrationServiceクラスを修正します。先ほどのSQLを使用してレコードがあるかを判定するためのexistsAccountメソッドを実装します。また、registerメソッドでそれを呼び出し、結果をAccountRegistrationResultで返すように修正します。 public AccountRegistrationResult register(String userName, String password) { if (existsAccount(userName)) { return AccountRegistrationResult.NAME_CONFLICT; } String userId = generateUserId(); insertAccount(userId, password); insertUserProfile(userId, userName); return AccountRegistrationResult.SUCCESS; } private boolean existsAccount(String userName) { Map condition = Map.of(\"userName\", userName); return UniversalDao.exists(UserProfileEntity.class, \"FIND_BY_USERNAME\", condition); } 続いて、AuthenticationActionクラスを修正します。 Nablarchでは、HttpErrorResponse（Javadoc）の例外を送出することで、エラーレスポンスを返すことができます。AccountRegistrationService#registerからfalseが返ってきたら、ステータスコードが409 Conflictのエラーレスポンスになるように実装します。 ... AccountRegistrationResult result = registrationService.register(requestBody.userName, requestBody.password); if (result == AccountRegistrationResult.NAME_CONFLICT) { throw new HttpErrorResponse(HttpResponse.Status.CONFLICT.getStatusCode()); } ... もう一度テストを実行し、成功することを確認します。 これで、サインアップのREST APIの実装は完了です。 "},"auth/backend/login/":{"url":"auth/backend/login/","title":"ログインのREST API","keywords":"","body":"ログインのREST API ログインに使用するREST APIを実装します。 ログイン機能を実装するためには、ログイン状態を何らかの仕組みで保持する必要があります。これを実現するために、Nablarchのセッションストアを使用します。（参考：セッションストア | Nablarch） また、NablarchではユーザーIDを設定することで、スレッドコンテキスト機能やログ出力機能等で使用することができます。（参考：ユーザーIDを設定する | Nablarch） ここでは、ログイン中のユーザーIDがNablarchのユーザーIDとして設定されるように、規定のキーを使用してセッションストアに保持するようにします。 セッションストアの設定 セッションストアを使うために、いくつかの設定が必要になります。 SessionManagerの設定 まず、SessionManagerのコンポーネント定義を設定するために、rest-component-configuration.xmlファイルに次の定義を追加します。 nablarch/webui/session-store.xmlファイルは、Nablarchが提供しているデフォルト設定の一つであり、セッションストアに関連するコンポーネント郡が定義されているため、これを読み込みます。（参考：デフォルト設定一覧 | Nablarch） セッションストアの保存先は複数あり、デフォルト設定では全てのセッションストアを使用できる設定になっています。（参考：セッションストアの特徴と選択基準 | Nablarch） ここではHTTPセッションストアのみ利用するため、sessionManager名のコンポーネント定義を上書きし、HTTPセッションストアのみ使用できる設定に変更しておきます。 セッション変数保存ハンドラの設定 次に、セッション変数保存ハンドラを設定します。 webFrontController名で定義しているコンポーネントのhandlerQueueプロパティに、REST APIの呼び出しで実行するハンドラを設定するため、ここにセッション変数保存ハンドラを追加します。セッション変数保存ハンドラは、先ほど読み込んだNablarchのデフォルト設定の中でsessionStoreHandler名のコンポーネントとして定義されているため、threadContextHandlerの手前に追加します。 ... ... これで、セッションストアの設定は完了です。 ユーザー認証処理の実装 ログインでは名前とパスワードを使用した認証を行うため、ユーザー認証処理を実装します。 名前でアカウント検索するSQLの作成 ユーザー認証では名前とパスワードを使用しますが、それぞれテーブルが分かれています。ユニバーサルDAOでは、テーブルを結合して検索する場合はSQLを作成する必要があります。（参考：テーブルをJOINした検索結果を取得する | Nablarch） 先ほど作成したAccountEntityクラスに対応するAccountEntity.sqlファイルを作成し、SQLを定義します。 src/main/resources/com/example/authentication/application/entity/AccountEntity.sql FIND_BY_USERNAME = select account.user_id, account.password FROM account INNER JOIN user_profile ON account.user_id = user_profile.user_id WHERE user_profile.name = :userName ユーザー認証クラスの作成 ユーザー認証処理を実装するため、まずは認証結果を表すAuthenticationResultクラスを作成します。 package com.example.authentication.application; public class AuthenticationResult { private final Status status; private final String userId; private AuthenticationResult(Status status, String userId) { this.status = status; this.userId = userId; } public static AuthenticationResult success(String userId) { return new AuthenticationResult(Status.SUCCESS, userId); } public static AuthenticationResult passwordMismatch() { return new AuthenticationResult(Status.PASSWORD_MISMATCH, null); } public boolean isFailed() { return status != Status.SUCCESS; } public String userId() { if (isFailed()) { throw new UnsupportedOperationException(); } return userId; } private enum Status { SUCCESS, PASSWORD_MISMATCH } } 続いて、AuthenticationServiceクラスを作成します。 package com.example.authentication.application; import com.example.authentication.application.entity.AccountEntity; import nablarch.common.dao.NoDataException; import nablarch.common.dao.UniversalDao; import nablarch.core.repository.di.config.externalize.annotation.SystemRepositoryComponent; import java.util.Map; @SystemRepositoryComponent public class AuthenticationService { public AuthenticationResult authenticate(String userName, String password) { AccountEntity accountEntity = findAccount(userName); if (!password.equals(accountEntity.getPassword())) { return AuthenticationResult.passwordMismatch(); } return AuthenticationResult.success(accountEntity.getUserId()); } private AccountEntity findAccount(String userName) { Map condition = Map.of(\"userName\", userName); return UniversalDao.findBySqlFile(AccountEntity.class, \"FIND_BY_USERNAME\", condition); } } ユニバーサルDAOを使用してDBからユーザーIDとパスワードを取得し、パスワードが一致すればユーザーIDも合わせて返すように実装します。 REST APIの実装 先ほど作成したAuthenticationActionクラスに、ログイン用のREST APIを実装します。 ... private final AccountRegistrationService registrationService; private final AuthenticationService authenticationService; public AuthenticationAction(AccountRegistrationService registrationService, AuthenticationService authenticationService) { this.registrationService = registrationService; this.authenticationService = authenticationService; } ... @Path(\"/login\") @POST @Consumes(MediaType.APPLICATION_JSON) public void login(ExecutionContext executionContext, LoginRequest requestBody) { ValidatorUtil.validate(requestBody); AuthenticationResult result = authenticationService.authenticate(requestBody.userName, requestBody.password); if (result.isFailed()) { throw new HttpErrorResponse(HttpResponse.Status.UNAUTHORIZED.getStatusCode()); } SessionUtil.invalidate(executionContext); SessionUtil.put(executionContext, \"user.id\", result.userId()); } public static class LoginRequest { @NotNull public String userName; @NotNull public String password; } ユーザー名とパスワードが送信されているかチェックし、先ほど実装したユーザー認証機能を呼び出します。 認証に成功したら、まずSessionUtil#invalidateを呼び出し、セッションを一度破棄して新しいセッションを使用するようにします。こうすることで、セッション管理の不備を狙ったセッション・ハイジャックの対策になります。（参考：セッション管理の不備 | 安全なウェブサイトの作り方） SessionUtil#invalidateの引数に必要なExecutionContextについては、アクションクラスのメソッドの引数に宣言することで、Nablarchから受け取ることができます。（参考：リソース(アクション)クラスの実装に関して | Nablarch） 認証に成功するとユーザーIDが返されるので、スレッドコンテキストのユーザーID属性に設定するため、セッションストアにuser.id名で保存します。（参考：ユーザーIDを設定する | Nablarch） パスワードが間違っていた場合はnullが返されるので、nullであれば認証失敗としてステータスコードが401 Unauthorizedのエラーレスポンスを返すように実装します。 REST APIのテスト テストデータの追加 テストで使用するテストデータを、V9999__testdata.sqlに追加します。 src/test/resources/db/testdata/V9999__testdata.sql INSERT INTO account (user_id, password) VALUES ('1010', 'pass'); INSERT INTO user_profile (user_id, name) VALUES ('1010', 'login-test'); 認証に成功するテストの作成 AuthenticationRestApiTestに、認証が成功する場合のテストを追加します。 @Test public void RESTAPIでログインできる() throws Exception { RestMockHttpRequest request = post(\"/api/login\") .setHeader(\"Content-Type\", MediaType.APPLICATION_JSON) .setBody(Map.of( \"userName\", \"login-test\", \"password\", \"pass\")); HttpResponse response = sendRequest(request); assertStatusCode(\"ログイン\", HttpResponse.Status.NO_CONTENT, response); openApiValidator.validate(\"login\", request, response); } 続いて、テストを実行する前準備として、PostgreSQLを起動しておきます。PostgreSQLのコンテナを起動していない場合は、backendディレクトリで次のコマンドを実行します。 $ docker-compose -f docker/docker-compose.dev.yml up -d 続いて、次のコマンドでコンテナが起動していることを確認します。 $ docker-compose -f docker/docker-compose.dev.yml ps Name Command State Ports ---------------------------------------------------------------------------------- docker_postgres_1 docker-entrypoint.sh postgres Up 0.0.0.0:5432->5432/tcp PostgreSQLが起動していることを確認できたら、Mavenでテストを実行します。 mvn test 特にエラーが発生せず、テストが成功することを確認します。 パスワードの不一致で認証に失敗するテストの作成 続けて、パスワードの不一致で認証に失敗する場合のテストを追加します。 @Test public void パスワードが不一致の場合_ログインに失敗して401になる() throws Exception { RestMockHttpRequest request = post(\"/api/login\") .setHeader(\"Content-Type\", MediaType.APPLICATION_JSON) .setBody(Map.of( \"userName\", \"login-test\", \"password\", \"fail\")); HttpResponse response = sendRequest(request); assertStatusCode(\"ログイン\", HttpResponse.Status.UNAUTHORIZED, response); openApiValidator.validate(\"login\", request, response); } テストを実行し、成功することを確認します。 名前の不一致で認証に失敗するテストの作成 続けて、名前の不一致で認証に失敗する場合のテストを追加します。 @Test public void 名前が不一致の場合_ログインに失敗して401になる() throws Exception { RestMockHttpRequest request = post(\"/api/login\") .setHeader(\"Content-Type\", MediaType.APPLICATION_JSON) .setBody(Map.of( \"userName\", \"fail-test\", \"password\", \"pass\")); HttpResponse response = sendRequest(request); assertStatusCode(\"ログイン\", HttpResponse.Status.UNAUTHORIZED, response); openApiValidator.validate(\"login\", request, response); } テストを実行すると、次のようにステータスコードが401 Unauthorizedではなく500 Internal Server Errorになり失敗します。 [ERROR] Failures: [ERROR] AuthenticationRestApiTest.名前の不一致でログインに失敗すると401になる:70->SimpleRestTestSupport.assertStatusCode:283->SimpleRestTestSupport.assertStatusCode:294 ログイン [HTTP STATUS] expected: but was: 他の出力結果を確認すると、次のようなスタックトレースが出力されており、先ほど実装したAuthenticationService#findAccountの中で呼び出しているUniversalDao#findBySqlFileで、NoDataExceptionの例外が送出されていることが分かります。 nablarch.common.dao.NoDataException at nablarch.common.dao.BasicDaoContext.findBySqlFile(BasicDaoContext.java:267) at nablarch.common.dao.UniversalDao.findBySqlFile(UniversalDao.java:165) at com.example.authentication.application.AuthenticationService.findAccount(AuthenticationService.java:48) UniversalDao#findBySqlFileのJavadocを確認すると、検索条件に該当するレコードが存在しない場合はNoDataExceptionの例外を送出すると定義されています。 名前で検索して見つからなかった場合はこれに該当するため、例外をハンドリングするように実装します。 まずは、AuthenticationResultクラスに、見つからなかった場合の結果を追加します。 public static AuthenticationResult nameNotFound() { return new AuthenticationResult(Status.NAME_NOT_FOUND, null); } ... private enum Status { SUCCESS, NAME_NOT_FOUND, PASSWORD_MISMATCH } 続いて、例外をハンドリングしてnullを返すようにAuthenticationServiceクラスのfindAccountメソッドを修正します。 private AccountEntity findAccount(String userName) { ... try { return UniversalDao.findBySqlFile(AccountEntity.class, \"FIND_BY_USERNAME\", condition); } catch (NoDataException e) { return null; } ... 同じクラスのauthenticateメソッドに、findAccountメソッドでnullが返された場合のために判定を追加します。 public AuthenticationResult authenticate(String userName, String password) { AccountEntity accountEntity = findAccount(userName); if (accountEntity == null) { return AuthenticationResult.nameNotFound(); } ... もう一度テストを実行し、成功することを確認します。 これで、ログインのREST APIの実装は完了です。 "},"auth/backend/logout/":{"url":"auth/backend/logout/","title":"ログアウトのREST API","keywords":"","body":"ログアウトのREST API ログアウトに使用するREST APIを実装します。 ログイン状態をセッションストアで保持しているため、これを破棄することでログアウトを実現します。 REST APIの実装 AuthenticationActionクラスに、ログアウト用のREST APIを実装します。 @Path(\"/logout\") @POST public void logout(ExecutionContext executionContext) { SessionUtil.invalidate(executionContext); } ログイン時と同様に、セッションを破棄するように実装します。 REST APIのテスト ログアウトに成功するテストの作成 AuthenticationRestApiTestに、ログアウトのテストを追加します。 @Test public void RESTAPIでログアウトできる() throws Exception { RestMockHttpRequest request = post(\"/api/logout\"); HttpResponse response = sendRequest(request); assertStatusCode(\"ログアウト\", HttpResponse.Status.NO_CONTENT, response); openApiValidator.validate(\"logout\", request, response); } 続いて、テストを実行する前準備として、PostgreSQLを起動しておきます。PostgreSQLのコンテナを起動していない場合は、backendディレクトリで次のコマンドを実行します。 $ docker-compose -f docker/docker-compose.dev.yml up -d 続いて、次のコマンドでコンテナが起動していることを確認します。 $ docker-compose -f docker/docker-compose.dev.yml ps Name Command State Ports ---------------------------------------------------------------------------------- docker_postgres_1 docker-entrypoint.sh postgres Up 0.0.0.0:5432->5432/tcp PostgreSQLが起動していることを確認できたら、Mavenでテストを実行します。 mvn test 特にエラーが発生せず、テストが成功することを確認します。 これで、ログアウトのREST APIの実装は完了です。 "},"auth/backend/check/":{"url":"auth/backend/check/","title":"REST APIへのアクセス制限","keywords":"","body":"REST APIへのアクセス制限 ログイン状態によるREST APIへのアクセス制御を実装します。 ユーザー認証を実装した後は、ログインしていなければToDoページを表示できないため、REST APIについても同様にログインしていなければアクセスできないようにします。 ここでは、ハンドラを実装することで実現します。ハンドラの実装についてはexample-chatのバックエンド実装から流用します。 ログインチェックハンドラの作成 まず、ハンドラのクラスを格納するcom.example.system.nablarch.handlerパッケージを作成します。 続いて、example-chatの同パッケージにあるLoginCheckHandlerクラスを持ってきます。 このクラスでは、ログインしていなくてもアクセスが可能なREST APIを設定することで、ログインしていない状態でそれ以外のREST APIへアクセスするとエラーレスポンスを返します。 対象のREST APIを設定 LoginCheckHandlerクラスはそのままではToDoアプリに合わないため、一部を修正していきます。 まず、対象のREST APIを設定するために、コンストラクタで設定している「ログインしていなくてもアクセスが可能なREST API」として、次のように修正します。 public LoginCheckHandler() { whitePatterns .add(\"/api/signup\", HttpMethod.POST) .add(\"/api/login\", HttpMethod.POST); } ログインチェック処理の修正 次に、ユーザーIDの取得方法と、エラーレスポンスの生成方法を変更するため、handleメソッドを次のように修正します。 @Override public Object handle(HttpRequest request, ExecutionContext context) { if (!whitePatterns.matches(request)) { if (ThreadContext.getUserId().equals(\"guest\")) { String path = request.getRequestPath(); String method = request.getMethod(); logger.logWarn(String.format(\"Unauthorized access to path. path=[%s] method=[%s]\", path, method)); throw new HttpErrorResponse(HttpResponse.Status.FORBIDDEN.getStatusCode()); } } return context.handleNext(request); } example-chatでは、セッションストアから独自の値を取得していますが、ここでは、スレッドコンテキストからユーザーIDを取得します。スレッドコンテキストからユーザーIDを取得するには、ThreadContext#getUserIdを使用します。（参考：スレッドコンテキストの属性値を設定/取得する | Nablarch） スレッドコンテキストにユーザーIDがされていない場合は、common.configに設定されている次の環境依存値がユーザーIDとして使用されます。 # 未ログイン時、ログに出力するユーザID nablarch.userIdAttribute.anonymousId=guest そのため、スレッドコンテキストのユーザーIDがここで設定している値であればログインしていないと判断するように変更します。 example-chatではエラーレスポンスを独自の例外で表現していますが、ここでは、今までの実装と同様に、HttpErrorResponseを使用するように変更します。 ハンドラを設定 LoginCheckHandlerクラスをハンドラとして設定するため、rest-component-configurationにあるwebFrontController名のコンポーネント定義を修正します。 ハンドラを設定するhandlerQueueプロパティの最後にあるpackageMapping名のハンドラの手前に、LoginCheckHandlerクラスをハンドラとして追加します。 ... REST APIのテスト ハンドラが有効になっているかを確認するため、REST APIのテストを実行します。 ハンドラが有効になっていれば、レスポンスのステータスコードが403 Forbiddenになり、いくつかのテストが失敗します。テストは失敗しますが、ハンドラが有効になっていることが確認できます。 次に、テストが成功するように修正していきます。REST APIテスティングフレームワークではCookieが使えないため、テスト開始時にセッションストアにユーザーIDを設定し、それに使用したExecutionContextをリクエスト送信時に使用するようにします。特定のExecutionContextをリクエスト送信時に使用するには、sendRequestメソッドではなくsendRequestWithContextメソッドを使用します。 ユーザー認証のテストではユーザーIDに1010を使用していますので、例えばログアウトのテストであれば、次のように修正します。 @Test public void RESTAPIでログアウトできる() { ExecutionContext executionContext = new ExecutionContext(); SessionUtil.put(executionContext, \"user.id\", \"1010\"); RestMockHttpRequest request = post(\"/api/logout\"); HttpResponse response = sendRequestWithContext(request, executionContext); ... Todo操作のテストではユーザーIDに1001を使用していますので、例えばTodo一覧取得のテストであれば、次のように修正します。 @Test public void RESTAPIでToDo一覧が取得できる() throws Exception { ExecutionContext executionContext = new ExecutionContext(); SessionUtil.put(executionContext, \"user.id\", \"1001\"); RestMockHttpRequest request = get(\"/api/todos\"); HttpResponse response = sendRequestWithContext(request, executionContext); ... 他のテストケースもこれらと同様に修正します。全て修正したら、もう一度テストを実行し、全てのテストが成功することを確認します。 これで、REST APIへのアクセス制御の実装は完了です。 "},"auth/e2e/":{"url":"auth/e2e/","title":"動作確認","keywords":"","body":"動作確認 ユーザー認証のフロントエンドとバックエンドの実装が完了したら、実際に接続して動作を確認します。 モックサーバの停止 モックサーバが起動している場合は、起動したコンソールでCtrl+Cを押して、モックサーバを停止させます。 DBコンテナの起動 PostgreSQLのDockerコンテナを起動していない場合は、バックエンドアプリを起動する前に起動します。既に起動している場合は、この手順はスキップしてください。 PostgreSQLをDockerコンテナで起動するため、backendディレクトリで次のコマンドを実行します。 $ docker-compose -f docker/docker-compose.dev.yml up -d 次のコマンドを実行し、コンテナが起動していることを確認します。 $ docker-compose -f docker/docker-compose.dev.yml ps Name Command State Ports ---------------------------------------------------------------------------------- docker_postgres_1 docker-entrypoint.sh postgres Up 0.0.0.0:5432->5432/tcp バックエンドアプリの起動 バックエンドアプリが起動していない場合は、backendディレクトリで次のコマンドを実行します。 $ mvn jetty:run 次のようにStartedと出力され、バックエンドアプリが起動されているこを確認します。 [INFO] Started ServerConnector@2299f6d7{HTTP/1.1,[http/1.1]}{0.0.0.0:9080} [INFO] Started Server@3751acd7{STARTING}[10.0.0.alpha1] @7133ms フロントエンドアプリの起動 フロントエンドアプリが起動していない場合は、frontendディレクトリで、次のコマンドを実行します。 $ npm start フロントエンドアプリが起動されたら、ブラウザが起動し、自動でトップページが開きます。 動作確認 アカウントを登録し、ログイン、ログアウトが動作することを確認します。 スクリプトでエラーが発生していないかを確認するため、ブラウザの開発者ツール（Chromeの場合はF12）を開きます。コンソール（Consoleタブ）を確認し、エラーが出力されていないことも確認します。 これで、動作確認は完了です。 "},"csrf/":{"url":"csrf/","title":"CSRF対策","keywords":"","body":"CSRF対策 REST API一覧の説明時にも紹介しましたが、Nablarchでは、クロスサイト・リクエスト・フォージェリ（以下CSRF）に対策するための機能が提供されています。（参考：CSRF | 安全なウェブサイトの作り方） CSRFトークンを発行してリクエスト毎にサーバーサイド側で保持してるCSRFトークンと突き合わせる方式であり、CSRFトークンを発行するためのユーティリティと、CSRFトークンを検証するためのハンドラが提供されています。（参考：CSRFトークン検証ハンドラ | Nablarch） ここでは、CSRF対策を実現するために、バックエンドでCSRFトークンを取得するREST APIを提供し、フロントエンドからはREST APIで取得したCSRFトークンを使用するように実装していきます。 バックエンド example-chatのバックエンドでも同様の実装をしているため、その実装を流用します。 バックエンドでは、CSRFトークンを取得するREST APIと、それを検証するためのハンドラを実装します。 CSRFトークンを取得するREST APIの作成 CSRFトークンを取得するREST APIについては、example-chatのcom.example.presentation.restapi.system.CsrfTokenActionクラスで同様の実装をしているため、このクラスをコピーして持ってきます。 CSRFトークン検証ハンドラの設定 CSRFトークンを検証するハンドラについては、Nablarchから提供されているため、これもコンポーネント定義に追加します。CSRFトークンを検証するハンドラではセッションを使用するため、セッション変数保存ハンドラ（ここではsessionStoreHandler）より後で実行されるように定義します。 ... ... ログインチェックハンドラの修正 CSRFトークンを取得するREST APIは、ログインしていなくてもアクセスできる必要があります。ログインしていなくてもアクセスできるパスは、ユーザー認証の実装時に作成したcom.example.system.nablarch.handler.LoginCheckHandlerクラスのコンストラクタで設定しているため、/api/csrf_tokenのパスを追加します。 public LoginCheckHandler() { whitePatterns .add(\"/api/signup\", HttpMethod.POST) .add(\"/api/login\", HttpMethod.POST) .add(\"/api/csrf_token\", HttpMethod.GET); } バックエンドのテスト 次に、バックエンドのテストを実行してみます。 mvn test すると、更新系の操作をするREST APIのテストが失敗します。これは、CSRFトークン検証ハンドラにより、リクエスト時にCSRFトークンが無ければ、ステータスコードが400 Bad Requestのエラーレスポンスとして返却されるためです。 そのため、テスト時にCSRFトークンを使用するように、テストクラスを修正します。 CSRFトークンを使用するには、先ほど実装したREST APIを使用してCSRFトークンとHTTPヘッダ属性名を取得し、リクエスト時のHTTPヘッダに設定する必要があります。 まず、テストクラスに次のようなprivateメソッドを実装します。 private void attachCsrfToken(RestMockHttpRequest request, ExecutionContext context) { HttpResponse response = sendRequest(get(\"/api/csrf_token\")); assertStatusCode(\"CSRFトークンの取得\", HttpResponse.Status.OK, response); String json = response.getBodyString(); String name = JsonPath.read(json, \"$.csrfTokenHeaderName\"); String value = JsonPath.read(json, \"$.csrfTokenValue\"); request.setHeader(name, value); WebConfig webConfig = WebConfigFinder.getWebConfig(); String storedVarName = webConfig.getCsrfTokenSessionStoredVarName(); String storeName = webConfig.getCsrfTokenSavedStoreName(); if (storeName != null) { SessionUtil.put(context, storedVarName, value, storeName); } else { SessionUtil.put(context, storedVarName, value); } } このメソッドでは、CSRFトークンを取得するREST APIを呼び出し、引数のリクエストオブジェクトへの設定と、サーバーサイドで比較元が保存されるセッションストアへの設定を実装しています。ExecutionContextを使用したセッションストアへの設定については、ユーザー認証でのテストクラスへの実装と同様に実装します。 各REST APIのテストで、REST APIにアクセスする前にこのattachCsrfTokenメソッドを呼び出すように修正します。 例えばサインアップのテストであれば、次のように修正します。 @Test public void RESTAPIでサインアップできる() { ExecutionContext executionContext = new ExecutionContext(); RestMockHttpRequest request = post(\"/api/signup\") .setHeader(\"Content-Type\", MediaType.APPLICATION_JSON) .setBody(Map.of( \"userName\", \"signup-test\", \"password\", \"pass\")); attachCsrfToken(request, executionContext); HttpResponse response = sendRequestWithContext(request, executionContext); ... 例えばログアウトのようにユーザーIDを設定しているテストであれば、次のように修正します。 @Test public void RESTAPIでログアウトできる() throws Exception { ExecutionContext executionContext = new ExecutionContext(); SessionUtil.put(executionContext, \"user.id\", \"1010\"); RestMockHttpRequest request = post(\"/api/logout\"); attachCsrfToken(request, executionContext); HttpResponse response = sendRequestWithContext(request, executionContext); ... 各REST APIのテストで同様の実装をすると、テストが成功します。 これでバックエンドの実装は完了です。 フロントエンド 続いて、フロントエンドを実装します。 REST APIクライアントへのCSRFトークン組込 生成したREST APIクライアントのラッパーを実装したBackendService.tsに、CSRFトークンを使用するための実装を追加します。 src/backend/BackendService.ts import { ... FetchParams, HTTPMethod, RequestContext } from './generated-rest-client'; class CsrfTokenAttachment implements Middleware { private readonly targetMethod: ReadonlyArray = ['POST', 'PUT', 'DELETE', 'PATCH']; private headerName = ''; private tokenValue = ''; setCsrfToken(headerName: string, tokenValue: string) { console.log('setCsrfToken:', headerName, tokenValue); this.headerName = headerName; this.tokenValue = tokenValue; } pre = async (context: RequestContext): Promise => { if (!this.headerName || !this.targetMethod.includes(context.init.method as HTTPMethod)) { return; } console.log('attach csrf token:', this.headerName, this.tokenValue); return { url: context.url, init: { ...context.init, headers : { ...context.init.headers, [this.headerName]: this.tokenValue } } }; } } const csrfTokenAttachment = new CsrfTokenAttachment(); const configuration = new Configuration({ middleware: [csrfTokenAttachment, corsHandler, requestLogger] }); ... const refreshCsrfToken = async () => { const response = await usersApi.getCsrfToken(); csrfTokenAttachment.setCsrfToken(response.csrfTokenHeaderName, response.csrfTokenValue); }; ... export const BackendService = { ... refreshCsrfToken }; すでに説明したとおり、生成したREST APIのクライアントコードでは、Middlewareと呼ばれる部品を作成することで、リクエストやレスポンスに対する共通的な処理を実装することができます。 まず、CSRFトークンをヘッダに設定するCsrfTokenAttachmentクラスを、Middlewareとして実装します。（CSRFトークンを状態として保持しやすくするよう、クラスとして実装します） Middlewareに追加するため、CsrfTokenAttachmentのオブジェクトを生成し、middlewareプロパティに追加します。 次に、CSRFトークン取得のREST APIを呼び出してCsrfTokenAttachmentに設定するrefreshCsrfToken関数を実装します。CSRFトークンはセッションストアに紐付いており、セッションが切り替わるタイミングでCSRFトークンも変更になるため、ログインやログアウト等のセッション切替タイミングで、この関数を実行してCSRFトークンを最新化します。 アプリ起動時のCSRFトークン設定 アプリ起動時にCSRFトークンを設定するため、Appコンポーネントで先ほど作成したrefreshCsrfToken関数を実行するように実装します。 function App() { const [initialized, setInitialized] = useState(false); useEffect(() => { BackendService.refreshCsrfToken() .finally(() => setInitialized(true)); }, []); if (!initialized) { return ( ); } ... refreshCsrfToken関数によるCSRFトークン取得が完了するまでは、他のコンポーネントを処理したくないため、それを制御するためのフラグとしてinitializedstateを作成します。refreshCsrfTokenの処理が終わるまでは、JSXで空要素を返すようにし、refreshCsrfTokenの処理が完了してinitializedがtrueになったタイミングで、今までと同様のコンポーネント処理を実行するようにします。 ログイン・ログアウト時のCSRFトークン設定 ログイン、ログアウト時に、セッションを破棄して新しく開始するようにしているため、ユーザーコンテクストにあるlogin、logout関数内で、先ほど作成したrefreshCsrfToken関数を実行するように実装します。 export const UserContextProvider: React.FC = ({ children }) => { ... const contextValue: ContextValueType = { ... login: async (userName, password) => { try { await BackendService.login(userName, password); await BackendService.refreshCsrfToken(); setUserName(userName); ... }, logout: async () => { await BackendService.logout(); await BackendService.refreshCsrfToken(); setUserName(''); ... これで、フロントエンドの実装は完了です。 動作確認 いままでと同じように、フロントエンドアプリとバックエンドアプリを起動し、動作を確認します。 内部的な処理であるため、ページの動作や見た目については、何も影響がありません。 CSRFトークンの取得や設定時にはconsole.logでログを出力していますので、ブラウザの開発者ツールでコンソールを確認してみましょう。次のようなログが出力され、正常に動作していることが確認できます。 >> GET /api/csrf_token Object { method: \"GET\", headers: {}, body: undefined, credentials: undefined } setCsrfToken: X-CSRF-TOKEN cb5a3ec0-c32f-47f7-b4a0-149f8ba41341 これで、CSRF対策の実装は完了です。 "},"todo-project/backend/":{"url":"todo-project/backend/","title":"バックエンドの確認","keywords":"","body":"バックエンドの確認 バックエンドを開発するためのプロジェクトを確認します。 バックエンド開発プロジェクトを確認する backendディレクトリが、バックエンド開発プロジェクトになります。 このプロジェクトは、NablarchのRESTfulウェブサービス構成で作成されています。（参考：Nablarch - RESTfulウェブサービス） Nablarchが提供しているブランクプロジェクトから作成し、次の変更を加えています。（参考：Nablarch - ブランクプロジェクト） 使用するJavaのバージョンを11に変更 開発環境で使用するアプリケーションサーバをJettyに変更 起動テスト用のアクションクラスとテストクラスを追加 Bean ValidationのメッセージとしてHibernate Validationのメッセージを使用する設定 nablarch.webApi.applicationPathの環境依存値を/apiに設定 使用しないファイルや定義を削除 ディレクトリ構造は、次のようになっています。 backend ├── .gitignore ├── pom.xml ├── docker │ └── docker-compose.dev.yml ├── rest-api-specification │ └── openapi.yaml └── src ├── main │ ├── java │ │ └── com │ │ └── example │ │ ├── SampleAction.java │ │ └── system │ │ └── nablarch │ │ ├── FlywayExecutor.java │ │ └── di │ │ └── ExampleComponentDefinitionLoader.java │ ├── resources │ │ ├── app-log.properties │ │ ├── common.config │ │ ├── data-source.config │ │ ├── env.config │ │ ├── log.properties │ │ ├── rest-boot.xml │ │ ├── rest-component-configuration.xml │ │ ├── db │ │ │ └── migration │ │ │ └── V1__create_table.sql │ │ └── META-INF │ │ └── services │ │ └── nablarch.core.repository.di.config.externalize.ExternalizedComponentDefinitionLoader │ └── webapp │ └── WEB-INF │ └── web.xml └── test ├── java │ └── com │ └── example │ └── SampleTest.java └── resources ├── log.properties └── unit-test.xml .gitignore Gitで管理対象外とするファイルを定義するためのファイルです。 ブランクプロジェクト作成時に生成されたものを使用しています。 pom.xml Mavenプロジェクトの定義ファイルです。 ブランクプロジェクト作成時に生成されたものをベースに使用しています。 docker/docker-compose.dev.yml データベース（PostgreSQL）を起動するDocker Composeの定義ファイルです。 rest-api-specification/openapi.yaml OpenAPI仕様でREST APIを定義したOpenAPIドキュメントです。 本ハンズオンで作成するREST APIについては、予め定義しています。 src/main/java/com/example/SampleAction.java 起動テスト用のREST APIを作成するためのアクションクラスです。（参考Nablarch - アプリケーションの責務配置） package com.example; import javax.ws.rs.GET; import javax.ws.rs.Path; import javax.ws.rs.Produces; import javax.ws.rs.core.MediaType; import java.util.Map; @SystemRepositoryComponent @Path(\"test\") public class SampleAction { @GET @Produces(MediaType.APPLICATION_JSON) public Object get() { return Map.of(\"status\", \"ok\"); } } Nablarchでは、ルーティングアダプタという機能で、リクエストをどのアクションクラスで処理するかを定義することができます。（参考：Nablarch - ルーティングアダプタ） JAX-RSのアノテーション（@PATHや@GET等）を使用してルーティングを定義できますので、パスがapi/test、HTTPメソッドがGETに対応した起動テスト用のREST APIを実装しています。（参考：ウィキペディア - JAX-RS） クラスに付与しているSystemRepositoryComponentアノテーションは、Nablarchが提供しているDIコンテナの機能を持つシステムリポジトリに登録するための設定です。（参考：Nablarch - システムリポジトリ） ToDoアプリでDIコンテナの機能を使うため、アクションクラスをシステムリポジトリから取得するように予め設定しています。そのため、アクションクラスをシステムリポジトリに登録する必要があります。 DIコンテナで管理するコンポーネントは、通常はXMLファイルを使用して定義しますが、その他にもSystemRepositoryComponentアノテーションを付与する方法もあり、このアプリではこちらの方法を使用します。（アノテーションを付与したクラスのオブジェクトを構築する | Nablarch） \"status\"キーで\"ok\"文字列を格納するMapオブジェクトを返していますが、これは次のようなJSONに変換されます。 { \"status\": \"ok\" } src/main/java/com/example/system/nablarch/FlywayExecutor.java バックエンドでは、マイグレーションツールであるFlywayを使用して、データベース上のテーブルやテストデータを登録するようにします。 Flywayを使用するための準備については、予め設定しています。（Maven Plugin | Flyway） Flywayの実行については、Nablarchの初期化処理を利用して、バックエンドアプリを起動したタイミングで行うように予め設定しています。（参考：Nablarch - オブジェクトの初期化処理を行う） example-chatのバックエンドでも同様の実装をしているため、その実装を流用しています。 ToDoアプリでは、アプリ起動時に毎回テーブルを初期化するように設定しています。テストを簡単に繰り返し実行できるようにするためにこのような設定としますが、テスト用途以外では指定しないように注意してください。 src/main/java/com/example/system/nablarch/di/ExampleComponentDefinitionLoader.java 前述のSystemRepositoryComponentアノテーションを付与してシステムリポジトリへ登録するための実装です。 src/main/resources/app-log.properties Nablarchで使用するログ出力用の定義ファイルです。 ブランクプロジェクト作成時に生成されたものを使用しています。 src/main/resources/common.config Nablarchで使用するプロパティ定義ファイルです。 ブランクプロジェクト作成時に生成されたものをベースに使用しています。 src/main/resources/data-source.xml Nablarchで使用するプロパティ定義ファイルです。 ブランクプロジェクト作成時に生成されたものをベースに使用しています。 src/main/resources/env.config Nablarchで使用するプロパティ定義ファイルです。 ブランクプロジェクト作成時に生成されたものをベースに使用しています。 src/main/resources/log.properties Nablarchで使用するログ出力用の定義ファイルです。 ブランクプロジェクト作成時に生成されたものを使用しています。 src/main/resources/rest-boot.xml Nablarchの使用するシステムリポジトリの定義ファイルです。 ブランクプロジェクト作成時に生成されたものをベースに使用しています。 src/main/resources/rest-component-configuration.xml Nablarchの使用するシステムリポジトリの定義ファイルです。 ブランクプロジェクト作成時に生成されたものをベースに使用しています。 src/main/resources/db/migration/V1__create_table.sql Flywayで実行するSQLを定義したファイルです。 src/main/resources/META-INF/services/nablarch.core.repository.di.config.externalize.ExternalizedComponentDefinitionLoader 前述のSystemRepositoryComponentアノテーションを付与してシステムリポジトリへ登録するための実装です。 src/main/webapp/WEB-INF/web.xml Java EEでWebアプリケーションを作成する際の定義ファイルです。 ブランクプロジェクト作成時に生成されたものをベースに使用しています。 src/test/java/com/example/SampleTest.java 動作確認を行うためのテストを定義したテストクラスです。 実行できれば無条件に成功するテストを実装しています。 package com.example; import org.junit.Test; import static org.junit.Assert.assertTrue; public class SampleTest { @Test public void test() { assertTrue(true); } } src/test/resources/log.properties Nablarchで使用するログ出力用の定義ファイルです。 ブランクプロジェクト作成時に生成されたものを使用しています。 src/test/resources/unit-test.xml テスト実行時にNablarchが使用するシステムリポジトリの定義ファイルです。 ブランクプロジェクト作成時に生成されたものをベースに使用しています。 バックエンドのアプリを起動する バックエンドのアプリはMavenプロジェクトであるため、Mavenを使用して動作を確認していきます。 まずは、コンパイルやテストが動作することを確認するため、backendディレクトリで次のコマンドを実行します。 $ mvn test 次のようにBUILD SUCCESSと出力されることを確認します。 [INFO] ------------------------------------------------------- [INFO] T E S T S [INFO] ------------------------------------------------------- [INFO] Running com.example.SampleTest [INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.048 s - in com.example.SampleTest [INFO] [INFO] Results: [INFO] [INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0 [INFO] [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ [INFO] Total time: 4.506 s [INFO] Finished at: 2020-08-07T09:55:45+09:00 [INFO] ------------------------------------------------------------------------ 次に、アプリケーションサーバのJettyでアプリを起動できることを確認します。 Nablarchでは起動時にデータベースに接続するため、アプリを起動する前に、PostgreSQLを起動しておきます。PostgreSQLをDockerコンテナで起動するため、Docker Composeを使用します。backendディレクトリで次のコマンドを実行します。 $ docker-compose -f docker/docker-compose.dev.yml up -d 続いて、コンテナが起動していることを確認するため、次のコマンドを実行します。 $ docker-compose -f docker/docker-compose.dev.yml ps docker_postgres_1のStateがUp（起動中）と出力されることを確認します。 Name Command State Ports ---------------------------------------------------------------------------------- docker_postgres_1 docker-entrypoint.sh postgres Up 0.0.0.0:5432->5432/tcp PostgreSQLを起動したら、続いてJettyを起動するため、次のコマンドを実行します。バックエンドのアプリの初期設定では、Jettyはlocalhost:9080で起動します。 $ mvn jetty:run 次のようにStartedと出力され、コマンドが実行中のままとなります。これでJettyが起動中の状態となっています。 [INFO] Started ServerConnector@2299f6d7{HTTP/1.1,[http/1.1]}{0.0.0.0:9080} [INFO] Started Server@3751acd7{STARTING}[10.0.0.alpha1] @7133ms Jettyが起動したら、起動テストを行います。 ブラウザを起動し、localhost:9080/api/testにアクセスします。 画面上に次のようなレスポンスが出力されることを確認します。 { status: \"ok\" } 起動テストが完了したら、PostgreSQLとJettyを停止しておきます。 まず、Jettyを終了するため、Jettyを起動して実行中となっているコンソールで、Ctrl+Cを押してコマンドを終了します。 Jettyを停止したら、続いてPostgreSQLを起動しているDockerコンテナを終了するため、次のコマンドを実行します。 $ docker-compose -f docker/docker-compose.dev.yml down 終了したことを確認するため、次のコマンドを実行します。 $ docker-compose -f docker/docker-compose.dev.yml ps 起動中のDockerコンテナとして出力されないことを確認します。 Name Command State Ports ------------------------------ "},"todo/frontend/component/":{"url":"todo/frontend/component/","title":"コンポーネントの分割","keywords":"","body":"コンポーネントの分割 ToDoページをコンポーネントに分割します。 コンポーネントへの落とし込み 次に、ToDoページをどのようなコンポーネント構造にするかを考え、コンポーネントに落とし込んでいきます。 ToDoページのデザインから、コンポーネントの階層構造に落とし込んでいきます。（参考：React - Reactの流儀 ステップ 1） 扱う情報の種類や用途から、ここでは以下のようにコンポーネントに分割します。 NavigationHeader（黄色）：ナビゲーションメニューのヘッダ TodoBoard（オレンジ色）：ToDoを扱うエリア TodoForm（青色）：新しいToDoを入力する TodoFilter（紫色）：ToDoの表示対象を選択する TodoList（緑色）：ToDoを一覧形式で表示する TodoItem（赤色）：ToDoを1行で表示する これらのコンポーネントを、以下のような階層構造で作成していきます。 NavigationHeader TodoBoard TodoForm TodoFilter TodoList TodoItem コンポーネントの作成 コンポーネントを作成するディレクトリとして、srcの下にcomponentsディレクトリを作成し、そこにコンポーネントを作成していきます。 ここでは、現在表示している静的なデータをそのまま使用して、それぞれのコンポーネントを作成していきます。（参考：React - Reactの流儀 ステップ 2） また、CSSファイルもそれぞれのコンポーネント単位に分割していきます。 importで読み込んだCSSファイルの適用範囲は、そのコンポーネント内だけでなく、全てのコンポーネント（グローバル）に適用されます。 そのため、この方法ではコンポーネント単位にCSSファイルを分けておく必要自体はありませんが、コンポーネント単位に分けることで、コンポーネント単位で取り回しがしやすかったり、適用範囲がコンポーネント単位になるような他の方法へ移行しやすくなる、といったメリットがあります。ただし、全体を把握しづらくなるため、予期せずスタイルが衝突してデザインが崩れてしまう、といったような事故が発生しやすいといったデメリットもあります。 ここでは、こういった事故を防ぐための配慮として、基本的にはクラス名を起点としたスタイル定義にして、クラス名の命名ルールを[コンポーネント名]_[任意文字列]とします。これにより、他のコンポーネントとクラス名が衝突することを防ぎ、事故が起きづらいようにしておきます。なお、デザインモックではすでにこのルールに則ったクラス名を使用しているため、デザインモックのCSSをそのまま使っていきます。 NavigationHeader NavigationHeaderコンポーネントを作成するため、NavigationHeader.tsxを作成します。NavigationHeaderが使用するCSSも分割するため、NavigationHeader.cssも作成します。 NavigationHeaderが返すReact要素には、Appから該当部分を抽出します。 src/components/NavigationHeader.tsx import React from 'react'; import './NavigationHeader.css'; export const NavigationHeader: React.FC = () => { return ( Todoアプリ テストユーザさん ログアウト ); }; src/components/NavigationHeader.css .PageHeader_header { display: flex; justify-content: space-between; align-items: center; padding: 0 5%; border-bottom: solid 1px black; background: black; } .PageHeader_title { color: white; font-size: 1.5rem; } .PageHeader_header a { text-decoration: none; } .PageHeader_nav { display: flex; list-style: none; } .PageHeader_nav li { margin-left: 30px; color: white; } .PageHeader_nav a { color: white; } .PageHeader_nav button, .PageHeader_nav button:active, .PageHeader_nav button:hover { cursor: pointer; border: 0; background-color: transparent; color: white; } NavigationHeaderでは、TypeScriptの構文を使用してNavigationHeaderの型にReact.FCを指定しています。React.FCは、Reactが提供している関数コンポーネントを表す型になります。TypeScriptでは変数:型というような構文で、型を付けることができます。 export const NavigationHeader: React.FC = () => { } NavigationHeaderが作成できたら、AppでNavigationHeaderを使用するように修正します。 src/App.tsx import React from 'react'; import './App.css'; import { NavigationHeader } from './components/NavigationHeader'; function App() { return ( ... ); } export default App; また、App.cssからNavigationHeader.cssに抽出した定義を削除します。 この時点でページの表示内容を確認すると、何も変わらず表示されていることを確認します。これでAppからNavigationHeader部分の抽出は完了です。 TodoBoard TodoBoardコンポーネントを作成するため、TodoBoard.tsxを作成します。TodoBoardが使用するCSSを分割するため、TodoBoard.cssも作成します。 TodoBoardが返すReact要素には、Appから該当部分を抽出します。このコンポーネントにはいくつかの子コンポーネントがありますが、少しずつ確認していくため、一度に作り込まずに一旦このコンポーネントで全て定義し、その後に分割していきます。 src/components/TodoBoard.tsx import React from 'react'; import './TodoBoard.css'; export const TodoBoard: React.FC = () => { return ( 追加 全て 未完了のみ 完了のみ 洗い物をする x 洗濯物を干す x 買い物へ行く x ); }; src/components/TodoBoard.css .TodoBoard_content { margin-top: 10px; width: 40%; padding: 0 30%; } .TodoForm_content { margin-top: 20px; margin-bottom: 20px; } .TodoForm_form { width: 100%; display: flex; justify-content: space-between; } .TodoForm_input { width: 86%; } .TodoForm_input input{ float: left; width: 95%; border-radius: 5px; padding: 8px; border: solid 1px lightgray; background-color: #fafbfc; font-size: 16px; outline: none; } .TodoForm_input input:focus { background-color: white; } .TodoForm_button { text-align: center; width: 14%; } .TodoForm_button button { height: 35px; cursor: pointer; line-height: 1; font-size: 1rem; color: white; background-color: darkgreen; border-radius: 5px; padding: 0 15px; border: none; vertical-align: middle; } .TodoForm_button button:hover { background-color: green; } .TodoFilter_content { text-align: right; } .TodoFilter_content button{ margin-left: 5px; } .TodoFilter_buttonSelected { background-color: #31b3c7; border-width: 0; color: #fff; cursor: pointer; justify-content: center; padding: 7px 16px; text-align: center; white-space: nowrap; border-radius: 290486px; outline: none; } .TodoFilter_buttonUnselected { background-color: lightgray; border-width: 0; color: gray; cursor: pointer; justify-content: center; padding: 7px 16px; text-align: center; white-space: nowrap; border-radius: 290486px; outline: none; } .TodoList_list { list-style: none; padding: 0; margin: 20px 0; } .TodoItem_item { padding: 15px 10px; background: whitesmoke; margin-bottom: 10px; } .TodoItem_todo { float: left; text-align: left; } .TodoItem_checkbox { margin-right: 7px; outline: none; } .TodoItem_delete { text-align: right; } .TodoItem_button { font-size: 17px; font-weight: bold; border: none; color: grey; background: lightgrey; border-radius: 100%; width: 25px; height: 25px; line-height: 20px; cursor: pointer; outline: none; } TodoBoardが作成できたら、AppでTodoBoardを使用するように修正します。 src/App.tsx import React from 'react'; import './App.css'; import { NavigationHeader } from './components/NavigationHeader'; import { TodoBoard } from './components/TodoBoard'; function App() { return ( ); } export default App; また、App.cssからTodoBoard.cssに抽出した定義を削除します。 ページの表示内容を確認すると、何も変わらず表示されていることを確認します。これでAppからTodoBoard部分の抽出は完了です。 TodoForm TodoBoardコンポーネントをさらに子コンポーネントに分割するため、TodoForm.tsxを作成します。TodoFormが使用するCSSを分割するため、TodoForm.cssも作成します。 TodoFormが返すReact要素には、TodoBoardから該当部分を抽出します。 src/components/TodoForm.tsx import React from 'react'; import './TodoForm.css'; export const TodoForm: React.FC = () => { return ( 追加 ); }; src/components/TodoForm.css .TodoForm_content { margin-top: 20px; margin-bottom: 20px; } .TodoForm_form { width: 100%; display: flex; justify-content: space-between; } .TodoForm_input { width: 86%; } .TodoForm_input input{ float: left; width: 95%; border-radius: 5px; padding: 8px; border: solid 1px lightgray; background-color: #fafbfc; font-size: 16px; outline: none; } .TodoForm_input input:focus { background-color: white; } .TodoForm_button { text-align: center; width: 14%; } .TodoForm_button button { height: 35px; cursor: pointer; line-height: 1; font-size: 1rem; color: white; background-color: darkgreen; border-radius: 5px; padding: 0 15px; border: none; vertical-align: middle; } .TodoForm_button button:hover { background-color: green; } TodoFormが作成できたら、TodoBoardでTodoFormを使用するように修正し、TodoBoard.cssからTodoForm.cssに抽出した定義を削除します。 ページの表示内容を確認すると、何も変わらず表示されていることを確認します。これでTodoBoardからTodoForm部分の抽出は完了です。 TodoFilter TodoBoardコンポーネントをさらに子コンポーネントに分割するため、TodoFilter.tsxを作成します。TodoFilterが使用するCSSを分割するため、TodoFilter.cssも作成します。 TodoFilterが返すReact要素には、TodoBoardから該当部分を抽出します。 src/components/TodoFilter.tsx import React from 'react'; import './TodoFilter.css'; export const TodoFilter: React.FC = () => { return ( 全て 未完了のみ 完了のみ ); }; src/components/TodoFilter.css .TodoFilter_content { text-align: right; } .TodoFilter_content button{ margin-left: 5px; } .TodoFilter_buttonSelected { background-color: #31b3c7; border-width: 0; color: #fff; cursor: pointer; justify-content: center; padding: 7px 16px; text-align: center; white-space: nowrap; border-radius: 290486px; outline: none; } .TodoFilter_buttonUnselected { background-color: lightgray; border-width: 0; color: gray; cursor: pointer; justify-content: center; padding: 7px 16px; text-align: center; white-space: nowrap; border-radius: 290486px; outline: none; } TodoFilterが作成できたら、TodoBoardでTodoFilterを使用するように修正し、TodoBoard.cssからTodoFilter.cssに抽出した定義を削除します。 ページの表示内容を確認すると、何も変わらず表示されていることを確認します。これでTodoBoardからTodoFilter部分の抽出は完了です。 TodoList TodoBoardコンポーネントをさらに子コンポーネントに分割するため、TodoList.tsxを作成します。TodoListが使用するCSSを分割するため、TodoList.cssも作成します。 TodoListが返すReact要素には、TodoBoardから該当部分を抽出します。このコンポーネントにはいくつかの子コンポーネントがありますが、TodoBoard作成時と同様、一旦このコンポーネントで全て定義し、その後に分割していきます。 src/components/TodoList.tsx import React from 'react'; import './TodoList.css'; export const TodoList: React.FC = () => { return ( 洗い物をする x 洗濯物を干す x 買い物へ行く x ); }; src/components/TodoList.css .TodoList_list { list-style: none; padding: 0; margin: 20px 0; } .TodoItem_item { padding: 15px 10px; background: whitesmoke; margin-bottom: 10px; } .TodoItem_todo { float: left; text-align: left; } .TodoItem_checkbox { margin-right: 7px; } .TodoItem_delete { text-align: right; } .TodoItem_button { font-size: 17px; font-weight: bold; border: none; color: grey; background: lightgrey; border-radius: 100%; width: 25px; line-height: 20px; cursor: pointer; } TodoListが作成できたら、TodoBoardでTodoListを使用するように修正し、TodoBoard.cssからTodoList.cssに抽出した定義を削除します。 ページの表示内容を確認すると、何も変わらず表示されていることを確認します。これでTodoBoardからTodoList部分の抽出は完了です。 この時点で、TodoBoardのコンポーネント分割は完了したため、TodoBoard.tsxは次のようになっています。 src/components/TodoBoard.tsx import React from 'react'; import './TodoBoard.css'; import { TodoForm } from './TodoForm'; import { TodoFilter } from './TodoFilter'; import { TodoList } from './TodoList'; export const TodoBoard: React.FC = () => { return ( ); }; src/components/TodoBoard.css .TodoBoard_content { margin-top: 10px; width: 40%; padding: 0 30%; } TodoItem TodoListコンポーネントをさらに子コンポーネントに分割するため、TodoItem.tsxを作成します。TodoItemが使用するCSSを分割するため、TodoItem.cssも作成します。 TodoItemが返すReact要素には、TodoListから該当部分を抽出しますが、TodoItemは複数配置し、それぞれの表示内容が異なります。このような場合には、コンポーネントにプロパティを定義し、親コンポーネントから引数で値を受け取るようにします。（参考：コンポーネントに props を渡す） ここでは、TypeScriptの構文であるtypeを使用し、プロパティの型を定義した型エイリアスを定義します。それをコンポーネントの型であるReact.FCの型引数として渡すことで、コンポーネントの引数をそれらの型でチェックすることができます。 type Props = { text: string completed: boolean } 受け取った引数は、ページ作成時に実装したcheckedと同様、中括弧で囲うことによりJSXで使用することができますので、TodoItem.tsxの実装は次のとおりになります。 src/components/TodoItem.tsx import React from 'react'; import './TodoItem.css'; type Props = { text: string completed: boolean } export const TodoItem: React.FC = ({text, completed}) => { return ( {text} x ); }; TodoListでは、次のようにしてTodoItemのプロパティに値を設定します。 src/components/TodoList.tsx import React from 'react'; import './TodoList.css'; import { TodoItem } from './TodoItem'; export const TodoList: React.FC = () => { return ( ); }; CSSファイルは他とのコンポーネントと同様に抽出します。 src/components/TodoItem.css .TodoItem_item { padding: 15px 10px; background: whitesmoke; margin-bottom: 10px; } .TodoItem_todo { float: left; text-align: left; } .TodoItem_checkbox { margin-right: 7px; outline: none; } .TodoItem_delete { text-align: right; } .TodoItem_button { font-size: 17px; font-weight: bold; border: none; color: grey; background: lightgrey; border-radius: 100%; width: 25px; height: 25px; line-height: 20px; cursor: pointer; outline: none; } src/components/TodoList.css .TodoList_list { list-style: none; padding: 0; margin: 20px 0; } TodoItemが作成できたら、TodoListでTodoItemを使用するように修正し、TodoList.cssからTodoItem.cssに抽出した定義を削除します。 ページの表示内容を確認すると、何も変わらず表示されていることを確認します。これでTodoListからTodoItem部分の抽出は完了です。 これで、コンポーネントの分割は完了です。 "},"todo/e2e/":{"url":"todo/e2e/","title":"動作確認","keywords":"","body":"動作確認 フロントエンドとバックエンドを接続して動作を確認します。 DBコンテナの起動 PostgreSQLのDockerコンテナを起動していない場合は、バックエンドアプリを起動する前に起動します。既に起動している場合は、この手順はスキップしてください。 PostgreSQLをDockerコンテナで起動するため、backendディレクトリで次のコマンドを実行します。 $ docker-compose -f docker/docker-compose.dev.yml up -d 次のコマンドを実行し、コンテナが起動していることを確認します。 $ docker-compose -f docker/docker-compose.dev.yml ps Name Command State Ports ---------------------------------------------------------------------------------- docker_postgres_1 docker-entrypoint.sh postgres Up 0.0.0.0:5432->5432/tcp バックエンドアプリの起動 バックエンドアプリを起動するため、backendディレクトリで次のコマンドを実行します。 $ mvn jetty:run 次のようにStartedと出力され、バックエンドアプリが起動されているこを確認します。 [INFO] Started ServerConnector@2299f6d7{HTTP/1.1,[http/1.1]}{0.0.0.0:9080} [INFO] Started Server@3751acd7{STARTING}[10.0.0.alpha1] @7133ms フロントエンド開発時に使用するモックサーバは、バックエンドアプリと同じ9080ポートを使用しています。そのため、モックサーバが起動している状態でアプリを起動すると、Error starting jetty: Failed to bind to 0.0.0.0/0.0.0.0:9080: Address already in useといったようにアドレスが使用済みである旨のエラーが発生します。もし発生した場合は、モックサーバを停止してから、再度バックエンドアプリを起動してください。 フロントエンドアプリの起動 フロントエンドアプリを起動するため、frontendディレクトリで、次のコマンドを実行します。 $ npm start フロントエンドアプリが起動されたら、ブラウザが起動し、自動でトップページが開きます。 ToDoページの表示内容を確認する ToDoページが表示され、ToDoを登録したり表示したりすることが問題なくできることを確認します。 "},"auth/frontend/routing/":{"url":"auth/frontend/routing/","title":"ルーティングの設定","keywords":"","body":"ルーティングの設定 SPAでは1つのページを動的に書き換えるため、ページ内容が書き換わってもそのままではURLは変わりません。しかし、ブックマークやページ履歴を利用したい場合等、ページ内容に応じてURLを変更したい場面があります。ToDoアプリでも、ユーザー認証を作成したことで目的が異なるページ内容が複数できたため、URLでページ内容が切り替わるように実装します。 ページは次の4つに分類し、それぞれにパスを割り当てます。 / ：トップページ /signup ：サインアップページ /login ：ログインページ /board ：ToDoページ URLと同様に、ページの題名要素もそのままでは変わりません。本ハンズオンでは実装しませんが、変更が必要な場合にはuseEffect等を利用して実装する必要があります。 React Routerの導入 ルーティングを実現するために、React用のルーティングライブラリであるReact Routerを導入します。 React Routerを使用することで、URLごとに使用するコンポーネントを制御したり異なるURLへ移動したりといったことを、簡単に実装することができます。 React RouterとTypeScript用の型定義をインストールするため、frontendディレクトリで次のコマンドを実行します。 npm install --save react-router-dom@5 @types/react-router-dom@5 ルーティングの設定 URLごとに使用するコンポーネントが切り替わるように実装するため、Appコンポーネントを次のように実装します。 import React from 'react'; import './App.css'; import { NavigationHeader } from './components/NavigationHeader'; import { TodoBoard } from './components/TodoBoard'; import { BrowserRouter, Route, Switch } from 'react-router-dom'; import { Signup } from './components/Signup'; import { Login } from './components/Login'; import { Welcome } from './components/Welcome'; function App() { return ( ); } export default App; まず、React Routerを有効にするため、BrowserRouterコンポーネントを使用します。 次に、URLによるルーティングを行うため、SwitchコンポーネントとRouteコンポーネントを使用します。（参考：Basic Routing | React Router） Switchコンポーネントの中でURLルーティングが有効になり、Routeコンポーネントのpathプロパティに指定されたURLにマッチしたら、子要素のコンポーネントが実行されます。 URLとのマッチングは、デフォルトでは部分一致で判定されるため、ここでは、完全一致を使用するためにexactプロパティを指定します。 ページ遷移の実装 トップページからサインアップページへの遷移 トップページからサインアップページへ遷移するため、Welcomeコンポーネントを次のように実装します。 src/components/Welcome.tsx import React from 'react'; import {Link} from 'react-router-dom'; import './Welcome.css'; export const Welcome: React.FC = () => { return ( Welcome 登録する ); }; 「登録する」ボタンがクリックされたら/signupURLへ遷移するように、Linkコンポーネントを使用します。toプロパティには、遷移先のURLを指定します。（参考：Basic Routing | React Router） サインアップ後のトップページへの遷移 サインアップしたらトップページへ遷移するため、Signupコンポーネントを次のように実装します。 src/components/Signup.tsx import React from 'react'; import { useHistory } from 'react-router-dom'; import './Signup.css'; export const Signup: React.FC = () => { const history = useHistory(); const signup: React.FormEventHandler = async (event) => { event.preventDefault(); history.push('/'); }; return ( ユーザー登録 名前 パスワード 登録する ); }; ReactRouterが提供しているフックのuseHistoryを使うことで、コンポーネントの処理中にURL遷移を行うことができます。（参考：useHistory） ここでは、「登録する」ボタンをクリックしたら、トップページに遷移するようにします。最終的にはアカウントの登録処理が完了したら遷移するように実装しますが、ここではまず遷移のみ実装しておきます。 ナビゲーションメニューからの遷移 ヘッダの「ログイン」リンクからログインページへ遷移するのと、同じくヘッダの「ログアウト」からトップページへ遷移するため、NavigationHeaderコンポーネントを次のように実装します。 import React from 'react'; import './NavigationHeader.css'; import { Link } from 'react-router-dom'; export const NavigationHeader: React.FC = () => { const logout = async () => { window.location.href = '/'; }; return ( Todoアプリ ログイン テストユーザさん ログアウト ); }; ここでは、ログアウト時にページを読み込み直してReactの状態を安全に破棄するよう、ReactRouterではなくwindows.location.hrefを使用します。 ログイン後のToDoページへの遷移 ログインしたらToDoページへ遷移するため、Loginコンポーネントを次のように実装します。 src/components/Login.tsx import React from 'react'; import { useHistory } from 'react-router-dom'; import './Login.css'; export const Login: React.FC = () => { const history = useHistory(); const login: React.FormEventHandler = async (event) => { event.preventDefault(); history.push('/board'); }; return ( ログイン 名前 パスワード ログインする ); }; 動作確認 サインアップやログイン等の処理はまだ実装していませんが、ページを表示してページ遷移することができるようになりましたので、一度フロントエンドアプリを起動して、動作確認をしてみましょう。 フロントエンドアプリを起動していない場合は、frontendディレクトリで次のコマンドを実行します。 npm start フロントエンドアプリが起動したら、ページを操作して動作を確認します。 "},"auth/backend/todo/":{"url":"auth/backend/todo/","title":"ToDo管理でのユーザー取得","keywords":"","body":"ToDo管理でのユーザー取得 ToDo管理のREST APIで、ログインしたユーザーを使用するように修正します。 ToDo管理のREST APIを修正 ToDo管理の実装時には、ユーザーIDとしてダミー値を使用していましたが、スレッドコンテキストからユーザーIDを取得するように修正します。 TodosActionクラスでダミーのユーザーIDを生成している箇所を、次のように修正します。 String userIdValue = ThreadContext.getUserId(); UserId userId = new UserId(userIdValue); REST APIのテスト もう一度テストを実行し、成功することを確認します。 もしテストが失敗する場合は、先ほどのログインチェックハンドラのテスト時にテストクラスに加えたユーザーIDが、元々使用していたダミー値と異なっていないか確認しましょう。ログインチェックハンドラでの修正時には、まだREST APIの内部で使用するユーザーIDはダミー値であったため、どのようなユーザーIDをセッションストアに設定してもテストが成功していましたが、ここでの修正により想定しているユーザーIDでなければテストデータとマッチせずにテストが失敗するようになります。 これで、ToDo管理でのユーザー取得の実装は完了です。 "},"setup/install/":{"url":"setup/install/","title":"開発環境の準備","keywords":"","body":"開発環境の準備 ToDoアプリの開発で使用するツールをインストールします。 Node.jsのインストール フロントエンドの開発ではCreate React AppやTypeScriptを使用するため、Node.jsをインストールします。Node.jsのバージョンには 20 を使用します。 公式サイトの案内に沿って、インストールしてください。 使用する環境が既に整っている場合は、この手順をスキップしてください。 JDKのインストール バックエンドの開発ではJavaを使用するため、JDKをインストールします。Javaのバージョンには 11 を使用します。 JDKはいくつかありますが、ここでは、OpenJDKの1つであるEclipse Temurinをインストールします。 公式サイトの案内に沿って、インストールしてください。 使用する環境が既に整っている場合は、この手順をスキップしてください。 Mavenのインストール バックエンドの開発では構成管理にMavenを利用するため、Mavenをインストールします。Mavenのバージョンには 3.6 を使用します。 こちらからダウンロードおよび配置してください。 使用する環境が既に整っている場合は、この手順をスキップしてください。 Visual Studio Codeのインストール 開発時に使用するエディタをインストールします。 エディタは使い慣れたものなら何でもよいですが、何もインストールしていなければ、今回のハンズオンで使用するコードに対応できるVisual Studio Codeをインストールします。公式サイトの案内に沿って、インストールしてください。 エディタが既に整っている場合は、この手順をスキップしてください。 Javaの開発ツールはEclipseやIntelliJ IDEAがあります。それ以外にもいくつかのツールがありますので、お好みに合わせてご利用してください。 Docker(Docker Compose)のインストール 開発時にコンテナを使用するため、DockerとDocker Composeをインストールします。 WindowsでのDocker利用方法はいくつかありますが、ここではDocker Desktop for Windowsをインストールします。公式サイトの案内に沿って、インストールしてください。 使用する環境が既に整っている場合は、この手順をスキップしてください。 本ハンズオンでは、Dockerコンテナ起動時にローカルディレクトリをマウントします。Docker Desktop for WindowsやDocker Desktop for Macでローカルディレクトリをマウントするためには事前にファイル共有を許可しておく必要があります。Docker DesktopのSettings→Resources→FILE SHARINGから、本ハンズオンのプロジェクトを配置するドライブやディレクトリを共有可能に設定しておいてください。（参考：File Sharing | Windows、File Sharing | Mac） Gitのインストール（オプション） ハンズオン資料のダウンロードでGitを利用することもできるため、Gitをインストールします。ただし、他の手段でもダウンロードが出来るため、インストールは必須ではなく任意となります。 ここでは、Windows用にGitを使うための git fow windows をインストールします。公式サイトの案内に沿って、インストールしてください。 "},"todo/backend/todo-list/":{"url":"todo/backend/todo-list/","title":"ToDo一覧取得のREST API","keywords":"","body":"ToDo一覧取得のREST API ToDoの一覧を取得するために使用するREST APIを実装します。 OpenAPIドキュメントの確認 バックエンドのREST APIは、OpenAPIドキュメントの定義と合うように実装しますので、OpenAPIドキュメントを確認します。フロントエンドのREST APIクライアント作成で説明している内容と同じであるため、該当ページの「OpenAPIドキュメントの確認」を参照してください。 ダミーデータのToDoを取得する処理の実装 REST APIを実装する前に、REST APIから呼ぶToDoを取得する処理を実装します。 まず、DBからToDoを取得するところまでは一気に実装せず、想定どおりのJSONを返却するREST APIが作成できることを確認します。 そのため、この段階では、DBからToDoを取得するのではなく、ダミーデータを固定で返すように実装しておきます。 なお、この部分の設計についてはREST APIとは直接関係がありませんので、詳細な説明は省略します。 com.example.todo.domainパッケージの作成 ToDo管理で扱うモデルを表すクラスを配置するための、com.example.todo.domainパッケージを作成します。 TodoIdクラスの作成 まず、ToDoを識別するためのIDを表すTodoIdクラスを作成します。 package com.example.todo.domain; public class TodoId { private final Long value; public TodoId(Long value) { this.value = value; } public Long value() { return value; } } このような何のための値であるかを専用の型で表現する方法は、一般的に「値オブジェクト（バリューオブジェクト）」と呼ばれます。何の値であるかを型で区別できるようにすることで、ミスを防ぎやすくしたり、どこでどのように使われるのかを特定しやすくしたりします。 TodoTextクラスの作成 続いて、ToDoの内容を表すTodoTextクラスを作成します。 package com.example.todo.domain; public class TodoText { private final String value; public TodoText(String value) { this.value = value; } public String value() { return value; } } TodoStatusクラスの作成 続いて、ToDoの状態を表すTodoStatusクラスを作成します。 package com.example.todo.domain; public enum TodoStatus { INCOMPLETE, COMPLETED } ここでは、JSONやテーブルで扱うboolean値をそのまま扱わず、状態を名前で扱うためにEnumを使用します。 UserIdクラスの作成 続いて、ユーザーIDを表すUserIdクラスを作成します。 package com.example.todo.domain; public class UserId { private final String value; public UserId(String value) { this.value = value; } public String value() { return value; } } Todoクラスの作成 続いて、ToDoを表すTodoクラスを作成します。 package com.example.todo.domain; public class Todo { private final TodoId id; private final TodoText text; private final TodoStatus status; private final UserId userId; public Todo(TodoId id, TodoText text, TodoStatus status, UserId userId) { this.id = id; this.text = text; this.status = status; this.userId = userId; } public TodoId id() { return id; } public TodoText text() { return text; } public TodoStatus status() { return status; } public UserId userId() { return userId; } } コンストラクタでのみ状態を設定し、生成後に状態を変更できないオブジェクトは、一般的に「イミュータブル（不変）」なオブジェクトと呼ばれます。オブジェクトをやり取りする中で、意図せずオブジェクトの状態を更新されてしまうといったバグを防ぎやすくしたりします。 com.example.todo.applicationパッケージの作成 ToDo管理の機能を表すクラスを配置するための、com.example.todo.applicationパッケージを作成します。 TodoRepositoryインターフェースの作成 まず、ToDo管理の永続化処理を呼び出すためのインターフェースとなる、TodoRepositoryインターフェースを作成します。 package com.example.todo.application; import com.example.todo.domain.Todo; import com.example.todo.domain.UserId; import java.util.List; public interface TodoRepository { List list(UserId userId); } TodoServiceクラスの作成 続いて、ToDoの操作を行うためのTodoServiceを作成します。REST APIからは、このクラスのメソッドを呼び出して、ToDo管理の機能を使用します。 package com.example.todo.application; import com.example.todo.domain.Todo; import com.example.todo.domain.UserId; import nablarch.core.repository.di.config.externalize.annotation.SystemRepositoryComponent; import java.util.List; @SystemRepositoryComponent public class TodoService { private final TodoRepository todoRepository; public TodoService(TodoRepository todoRepository) { this.todoRepository = todoRepository; } public List list(UserId userId) { List todos = todoRepository.list(userId); return todos; } } このクラスはコンポーネントとしてDIコンテナに登録するため、@SystemRepositoryComponentを付与します。TodoRepositoryのインスタンスについては、DIコンテナによりコンストラクタインジェクションで設定されるようにします。（参考：Nablarch - コンポーネントを自動的にインジェクションする） com.example.todo.infrastructureパッケージの作成 ToDo管理の永続化処理を実装するクラスを配置するための、com.example.todo.infrastructureパッケージを作成します。 JdbcTodoRepositoryクラスの作成 TodoRepositoryインターフェースを実装したJdbcTodoRepositoryクラスを作成します。 ここにはDBにアクセスする処理を実装する予定ですが、前述のとおり、一旦ダミーデータを返す処理を実装しておきます。 package com.example.todo.infrastructure; import com.example.todo.application.TodoRepository; import com.example.todo.domain.*; import nablarch.core.repository.di.config.externalize.annotation.SystemRepositoryComponent; import java.util.List; @SystemRepositoryComponent public class JdbcTodoRepository implements TodoRepository { @Override public List list(UserId userId) { return List.of( new Todo(new TodoId(2001L), new TodoText(\"やること１\"), TodoStatus.COMPLETED, new UserId(\"1001\")), new Todo(new TodoId(2002L), new TodoText(\"やること２\"), TodoStatus.INCOMPLETE, new UserId(\"1001\")) ); } } REST APIの作成 com.example.todo.apiパッケージの作成 REST APIを実装するクラスを配置するための、com.example.todo.apiパッケージを作成します。 TodosActionクラスの作成 登録しているToDoを取得するためのREST APIを実装するTodosActionを作成します。 package com.example.todo.api; import com.example.todo.domain.*; import com.example.todo.application.TodoService; import nablarch.core.repository.di.config.externalize.annotation.SystemRepositoryComponent; import javax.ws.rs.GET; import javax.ws.rs.Path; import javax.ws.rs.Produces; import javax.ws.rs.core.MediaType; import java.util.List; import java.util.stream.Collectors; @SystemRepositoryComponent @Path(\"/todos\") public class TodosAction { private final TodoService todoService; public TodosAction(TodoService todoService) { this.todoService = todoService; } @GET @Produces(MediaType.APPLICATION_JSON) public List get() { UserId userId = new UserId(\"1001\"); List todos = todoService.list(userId); return todos.stream() .map(todo -> new TodoResponse(todo.id(), todo.text(), todo.status())) .collect(Collectors.toList()); } public static class TodoResponse { public final Long id; public final String text; public final Boolean completed; public TodoResponse(TodoId id, TodoText text, TodoStatus status) { this.id = id.value(); this.text = text.value(); this.completed = status == TodoStatus.COMPLETED; } } } このクラスはコンポーネントとしてDIコンテナに登録するため、@SystemRepositoryComponentを付与します。TodoServiceのインスタンスについては、DIコンテナによりコンストラクタインジェクションで設定されるようにします。 前述のとおり、JAX-RSのアノテーションを利用してREST APIを作成します。JAX-RSの@Pathアノテーションをクラスに、@GETアノテーションと@Producesアノテーションをメソッドに付与し、パス等の属性を指定します。 @Pathアノテーションをクラスに付与することで、このアクションクラスが対応するパスを指定します。 @GETアノテーションをメソッドに付与することで、HTTPメソッドがGETの場合にそのメソッドが呼び出されるようになります。 @Producesアノテーションは、レスポンスを返す際のContent-Typeを指定します。レスポンスはJSONで返すため、MediaType.APPLICATION_JSONを指定します。 メソッドの実装としては、さきほど作成したTodoServiceクラスのlist(UserId)メソッドを呼び出します。DBから取得するためのユーザーIDを渡す必要がありますが、今はまだユーザー認証を実装していないため、とりあえずダミーのユーザーIDを生成して渡しておきます。 レスポンスのオブジェクトがJSONに変換されるため、OpenAPIドキュメントに沿った値に変換されるようにTodoResponseクラスを内部で定義し、TodoSerivceから取得したオブジェクトを変換します。また、java.util.Listで返すことで配列形式に変換されるため、TodoResponse型のオブジェクトをListで返すことで、OpenAPIの定義時に想定していた次のようなJSONに変換されます。 { [ { \"id\": 2001, \"text\": \"やること１\", \"completed\": true }, { \"id\": 2002, \"text\": \"やること２\", \"completed\": false } ] } REST API（ダミーデータ）のテスト ToDoはダミーデータですが、アクションクラスを作成してREST APIを定義したため、このREST APIが想定している動作をするのか、テストします。 Nablarchでは、REST APIをテストするためテスティングフレームワークを提供していますので、それを使用してアプリサーバの起動およびREST APIの呼び出しをテストします。 REST APIのテスティングフレームワークを使用するための設定は、Nablarchのブランクプロジェクトで予め設定されているため、事前準備は必要ありません。 テストクラスの作成 テスト用Javaディレクトリのsrc/test/javaに、com.example.todo.apiパッケージを作成し、そこにTodoListRestApiTestクラスを作成します。 REST APIのテスティングフレームワークを使用するため、親クラスにnablarch.test.core.http.SimpleRestTestSupportクラスを指定します。 合わせて、最初のテストとしてREST APIが想定しているパスとHTTPメソッドで呼び出せるかをテストします。 package com.example.todo.api; import nablarch.fw.web.HttpResponse; import nablarch.fw.web.RestMockHttpRequest; import nablarch.test.core.http.SimpleRestTestSupport; import org.junit.Test; public class TodoListRestApiTest extends SimpleRestTestSupport { @Test public void RESTAPIでToDo一覧が取得できる() { RestMockHttpRequest request = get(\"/api/todos\"); HttpResponse response = sendRequest(request); assertStatusCode(\"ToDo一覧の取得\", HttpResponse.Status.OK, response); } } 親クラスのgetメソッド呼び出してパスを渡すことで、そのパスにGETでリクエストを送信するためのリクエストオブジェクトを生成できます。 生成したら、sendRequestメソッドにそのリクエストを渡すことで、リクエストが処理されてREST APIが呼び出されます。戻り値のレスポンスオブジェクトには、ステータスコードやレスポンスボディ等のレスポンスに関する情報が入っています。 ここでは、REST APIが呼び出せているかを確認するため、レスポンスのステータスコードが200 OKであるかを検証します。 テストクラスを作成したら、テストを実行します。 REST APIテスティングフレームワークではテスト実行時にアプリを起動するため、テストを実行する前準備として、PostgreSQLを起動しておきます。PostgreSQLのコンテナを起動していない場合は、backendディレクトリで次のコマンドを実行します。 $ docker-compose -f docker/docker-compose.dev.yml up -d 続いて、次のコマンドでコンテナが起動していることを確認します。 $ docker-compose -f docker/docker-compose.dev.yml ps Name Command State Ports ---------------------------------------------------------------------------------- docker_postgres_1 docker-entrypoint.sh postgres Up 0.0.0.0:5432->5432/tcp Mavenでテストを実行するため、次のコマンドを実行します。 mvn test 出力された内容から、TodoListRestApiTestテストが実行され、テストが成功していることを確認します。 レスポンスボディのJSONの検証 次は、ダミーデータのToDoが想定通りJSONに変換されていることを確認します。先ほどのテストメソッドを、次のように変更します。 package com.example.todo.api; import nablarch.fw.web.HttpResponse; import nablarch.fw.web.RestMockHttpRequest; import nablarch.test.core.http.SimpleRestTestSupport; import org.junit.Test; import static com.jayway.jsonpath.matchers.JsonPathMatchers.hasJsonPath; import static org.hamcrest.MatcherAssert.assertThat; import static org.hamcrest.Matchers.equalTo; import static org.hamcrest.Matchers.hasSize; public class TodoListRestApiTest extends SimpleRestTestSupport { @Test public void RESTAPIでToDo一覧が取得できる() { RestMockHttpRequest request = get(\"/api/todos\"); HttpResponse response = sendRequest(request); assertStatusCode(\"ToDo一覧の取得\", HttpResponse.Status.OK, response); String responseBody = response.getBodyString(); assertThat(responseBody, hasJsonPath(\"$\", hasSize(2))); assertThat(responseBody, hasJsonPath(\"$[0].id\", equalTo(2001))); assertThat(responseBody, hasJsonPath(\"$[0].text\", equalTo(\"やること１\"))); assertThat(responseBody, hasJsonPath(\"$[0].completed\", equalTo(true))); assertThat(responseBody, hasJsonPath(\"$[1].id\", equalTo(2002))); assertThat(responseBody, hasJsonPath(\"$[1].text\", equalTo(\"やること２\"))); assertThat(responseBody, hasJsonPath(\"$[1].completed\", equalTo(false))); } } ここでは、先ほど依存関係に追加したライブラリであるJsonPathを利用して、レスポンスとして返されたJSONに対して次の検証をします。（JsonPathでは、ルート要素を$で表します） 配列の要素数が2である 配列の1番目が、ダミーデータの1番目の値と同じである 配列の2番目が、ダミーデータの2番目と値と同じである 先ほどと同じく、Mavenでテストを実行し、テストが成功していることを確認します。 なお、ダミーデータを変えてみることでテストを失敗させることができるため、想定どおりに検証できるかやテスト失敗時の挙動を確認するために、わざと失敗するようにダミーデータを変更してテストを実行してみるのもよいです。 OpenAPIドキュメントによる型の検証 次に、OpenAPIドキュメントに記述したレスポンスの定義と、実際のレスポンスの内容が一致しているか検証します。 OpenAPIによりフロントエンドとREST APIに対する認識を合わせているため、OpenAPIドキュメントの定義と実際の実装が一致することを検証するのは重要になります。 ここでは、OpenAPIドキュメントを解析したり検証することができるOSSのOpenAPI4Jを使用します。 OpenAPI4Jを使用するための設定は済んだ状態になっているため、事前準備は必要ありません。（Operation validator | OpenAPI4J） OpenAPIドキュメントによる検証を実装するには、OpenAPI4Jから提供されているValidatorを使用します。example-chatのバックエンドでは、Nablarchで使いやすくするためにValidatorをラッピングしたクラスを実装しているため、その実装を流用します。 example-chatのテストソースにcom.example.openapi.OpenApiValidatorクラスがあるため、これをそのまま同じパッケージに持ってきます。 次に、先ほどのテストに、OpenAPIドキュメントの定義と一致するかを検証するためのテストコードを追加します。 package com.example.todo.api; import com.example.openapi.OpenApiValidator; import nablarch.fw.web.HttpResponse; import nablarch.fw.web.RestMockHttpRequest; import nablarch.test.core.http.SimpleRestTestSupport; import org.junit.Test; import java.nio.file.Paths; import static com.jayway.jsonpath.matchers.JsonPathMatchers.hasJsonPath; import static org.hamcrest.MatcherAssert.assertThat; import static org.hamcrest.Matchers.equalTo; import static org.hamcrest.Matchers.hasSize; public class TodoListRestApiTest extends SimpleRestTestSupport { public static OpenApiValidator openApiValidator = new OpenApiValidator(Paths.get(\"rest-api-specification/openapi.yaml\")); @Test public void RESTAPIでToDo一覧が取得できる() throws Exception { RestMockHttpRequest request = get(\"/api/todos\"); HttpResponse response = sendRequest(request); assertStatusCode(\"ToDo一覧の取得\", HttpResponse.Status.OK, response); String responseBody = response.getBodyString(); assertThat(responseBody, hasJsonPath(\"$\", hasSize(2))); assertThat(responseBody, hasJsonPath(\"$[0].id\", equalTo(2001))); assertThat(responseBody, hasJsonPath(\"$[0].text\", equalTo(\"やること１\"))); assertThat(responseBody, hasJsonPath(\"$[0].completed\", equalTo(true))); assertThat(responseBody, hasJsonPath(\"$[1].id\", equalTo(2002))); assertThat(responseBody, hasJsonPath(\"$[1].text\", equalTo(\"やること２\"))); assertThat(responseBody, hasJsonPath(\"$[1].completed\", equalTo(false))); openApiValidator.validate(\"getTodos\", request, response); } } 先ほどと同じく、Mavenでテストを実行し、テストが成功していることを確認します。 この検証では、値については検証されずに、あくまでJSONの項目と型が定義と一致するかを検証します。そのため、想定しているデータであるかどうかについては、JsonPath等を利用して検証する必要があります。 なお、TodoResponseの型を変更してみるなどして、想定どおりに検証できるかやテスト失敗時の挙動を確認することができるため、わざと失敗するように修正してテストを実行してみるのもよいです。 DBから取得する処理の実装 次に、先ほどダミーデータの取得として実装していた処理を、実際にDBから取得する処理に変更していきます。 NablarchでDBを操作するために、ユニバーサルDAOと呼ばれる機能を使用します。（参考：Nablarch - ユニバーサルDAO） com.example.todo.infrastructure.entityパッケージの作成 ユニバーサルDAOでは、Entityと呼ばれるクラスを使用して、DBの検索結果をEntityにマッピングします。そのため、まずはEntityを配置するためのcom.example.todo.infrastructure.entityパッケージを作成します。（参考：Nablarch - 検索結果をBeanにマッピングできる） TodoEntityクラスの作成 todoテーブルを先ほど作成しているため、todoテーブルに対応するTodoEntityクラスを作成します。 package com.example.todo.infrastructure.entity; import javax.persistence.*; @Entity @Table(name = \"todo\") @Access(AccessType.FIELD) public class TodoEntity { @Id private Long todoId; private String text; private Boolean completed; private String userId; public Long getTodoId() { return todoId; } public void setTodoId(Long todoId) { this.todoId = todoId; } public String getText() { return text; } public void setText(String text) { this.text = text; } public Boolean getCompleted() { return completed; } public void setCompleted(Boolean completed) { this.completed = completed; } public String getUserId() { return userId; } public void setUserId(String userId) { this.userId = userId; } } Entityクラスには、Entityを表すための@Entityアノテーションをクラスに付与します。 ユニバーサルDAOではEntityクラス名をテーブル名とみなしますが、ここではEntityクラス名はテーブル名と一致しないため、@Tableアノテーションを付与して、name属性でテーブル名を指定します。 JdbcTodoRepositoryクラスの修正 先ほどダミーデータを返す処理を実装したJdbcTodoRepositoryクラスを、ユニバーサルDAOを使用してDBからデータを取得するように修正します。 package com.example.todo.infrastructure; import com.example.todo.application.TodoRepository; import com.example.todo.domain.*; import com.example.todo.infrastructure.entity.TodoEntity; import nablarch.common.dao.EntityList; import nablarch.common.dao.UniversalDao; import nablarch.core.repository.di.config.externalize.annotation.SystemRepositoryComponent; import java.util.List; import java.util.Map; import java.util.stream.Collectors; @SystemRepositoryComponent public class JdbcTodoRepository implements TodoRepository { @Override public List list(UserId userId) { Map condition = Map.of(\"userId\", userId.value()); EntityList todoEntities = UniversalDao.findAllBySqlFile(TodoEntity.class, \"FIND_BY_USERID\", condition); return todoEntities.stream().map(this::createTodo).collect(Collectors.toList()); } private Todo createTodo(TodoEntity entity) { return new Todo( new TodoId(entity.getTodoId()), new TodoText(entity.getText()), entity.getCompleted() ? TodoStatus.COMPLETED : TodoStatus.INCOMPLETE, new UserId(entity.getUserId())); } } ここでは、ユーザーIDに紐づくToDoを取得しますが、ユーザーIDはtodoテーブルの主キーではありません。ユニバーサルDAOでは、主キーを使用しない検索にはSQLファイルを使用します。（参考：Nablarch - 任意のSQLで検索する） SQLファイルは後ほど作成しますので、使用するSQLのIDをFIND_BY_USERID、パラメータをuserIdとして実装します。 com/example/todo/infrastructure/entityディレクトリの作成 ユニバーサルDAOで使用するSQLファイルを使用するためには、Entityクラスと同じクラスパス上にSQLファイルを配置する必要がある。 そのため、まずはsrc/main/resourcesの下にcom/example/todo/infrastructure/entityディレクトリを作成します。 TodoEntity.sqlファイルの作成 作成したcom/example/todo/infrastructure/entityディレクトリ内に、TodoEntityクラスに対応するTodoEntity.sqlファイルを作成します。 FIND_BY_USERID = select * FROM todo WHERE user_id = :userId ORDER BY todo_id SQLファイル内のそれぞれのSQLにはIDが必要であるため、先ほど実装した際のIDとパラメータも記述します。（参考：SQLをファイルで管理する） テストデータの作成 テスト実行時にDBにテストデータを投入するため、テスト用リソースディレクトリのsrc/test/resourcesに、db/testdataディレクトリを作成し、V9999__testdata.sqlファイルを作成します。ファイルには、テストデータを登録するためのSQLを記述します。 src/test/resouces/db/testdata/V9999__testdata.sql INSERT INTO account (user_id, password) VALUES ('1001', ''); INSERT INTO user_profile (user_id, name) VALUES ('1001', 'todo-test'); INSERT INTO todo (todo_id, text, completed, user_id) VALUES (2001, 'やること１', true, '1001'); INSERT INTO todo (todo_id, text, completed, user_id) VALUES (2002, 'やること２', false, '1001'); REST APIのテスト DBのテストデータは最初に作成したダミーデータと同じ値であるため、REST APIのテストケースはそのまま利用できます。後ほど実装する登録等のテストでも同じテストデータを利用するため、テスト実行順序でテスト結果が変わらないように、テスト前処理としてDB初期化処理を実装します。DB初期化処理にはFlywayのマイグレーションを利用します。 DB初期化処理を簡易に実装するためFlywayのマイグレーションを利用していますが、処理時間が増えるためテスト実行時間は遅くなってしまいます。ハンズオンコンテンツではテストケース数がわずかであるため問題ありませんが、使用する際にはご注意ください。 package com.example.todo.api; import com.example.openapi.OpenApiValidator; import com.example.system.nablarch.FlywayExecutor; import nablarch.core.repository.SystemRepository; import nablarch.fw.web.HttpResponse; import nablarch.fw.web.RestMockHttpRequest; import nablarch.test.core.http.SimpleRestTestSupport; import org.junit.BeforeClass; import org.junit.Test; import java.nio.file.Paths; import static com.jayway.jsonpath.matchers.JsonPathMatchers.hasJsonPath; import static org.hamcrest.MatcherAssert.assertThat; import static org.hamcrest.Matchers.equalTo; import static org.hamcrest.Matchers.hasSize; public class TodoListRestApiTest extends SimpleRestTestSupport { public static OpenApiValidator openApiValidator = new OpenApiValidator(Paths.get(\"rest-api-specification/openapi.yaml\")); @BeforeClass public static void setUpClass() { FlywayExecutor flywayExecutor = SystemRepository.get(\"dbMigration\"); flywayExecutor.migrate(true); } @Test public void RESTAPIでToDo一覧が取得できる() throws Exception { RestMockHttpRequest request = get(\"/api/todos\"); HttpResponse response = sendRequest(request); assertStatusCode(\"ToDo一覧の取得\", HttpResponse.Status.OK, response); String responseBody = response.getBodyString(); assertThat(responseBody, hasJsonPath(\"$\", hasSize(2))); assertThat(responseBody, hasJsonPath(\"$[0].id\", equalTo(2001))); assertThat(responseBody, hasJsonPath(\"$[0].text\", equalTo(\"やること１\"))); assertThat(responseBody, hasJsonPath(\"$[0].completed\", equalTo(true))); assertThat(responseBody, hasJsonPath(\"$[1].id\", equalTo(2002))); assertThat(responseBody, hasJsonPath(\"$[1].text\", equalTo(\"やること２\"))); assertThat(responseBody, hasJsonPath(\"$[1].completed\", equalTo(false))); openApiValidator.validate(\"getTodos\", request, response); } } テストが成功することを確認するため、再度Mavenでテストを実行してみます。 mvn test 特にエラーが発生せず、テストが成功することを確認します。 これで、ToDo一覧取得のREST APIの実装は完了です。 "}}